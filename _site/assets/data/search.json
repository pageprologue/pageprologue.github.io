[
  
  {
    "title"    : "[Java] 인스턴스를 복제하는 방법",
    "category" : "Programming",
    "tags" : "Study, Java",
    "url"      : "/programming/2022/05/17/clone/",
    "date"     : "May 17, 2022",
    "excerpt"  : "개발을 할 때 종종 값을 복제해서 사용하는 경우가 있습니다. 자바 언어에서 인스턴스를 복제하는 방법에는 얕은 복사와 깊은 복사가 있습니다. \n이번 포스트에서는 얕은 복사, 깊은 복사, 그리고 방어적 복사에 대해 살펴보도록 하겠습니다.\n\n복사본을 만드는 이유는 어떤 인스턴스에 대해 원본 인스턴스를 보존하고 새로운 인스턴스를 생성하면, 변경 전의 값도 유지되어 작업이 실패하는 경우에도 원본이 손상되지 않기 때문입니다.\n\n새로운 변수에 할당\n\n...",
    "content"  : "개발을 할 때 종종 값을 복제해서 사용하는 경우가 있습니다. 자바 언어에서 인스턴스를 복제하는 방법에는 얕은 복사와 깊은 복사가 있습니다. \n이번 포스트에서는 얕은 복사, 깊은 복사, 그리고 방어적 복사에 대해 살펴보도록 하겠습니다.\n\n복사본을 만드는 이유는 어떤 인스턴스에 대해 원본 인스턴스를 보존하고 새로운 인스턴스를 생성하면, 변경 전의 값도 유지되어 작업이 실패하는 경우에도 원본이 손상되지 않기 때문입니다.\n\n새로운 변수에 할당\n\n  복사본을 만드는 방법은 쉽게 생각해서 복사할 타입과 같은 변수를 하나 생성한 뒤 값을 할당해 줄 수 있습니다.\n    Color originColor = Color.of(&quot;blue&quot;);\nColor copyColor = originColor;\n    \n  \n  하지만 Color 객체가 불변객체가 아닌 경우, copyColor를 수정하면 originColor까지 변경됩니다.\n    copyColor.changeColor(&quot;sky&quot;);\n// 결과 : originColor = sky, copyColor = sky\n    \n  \n\n\ncopy 메서드\n\n  원본 인스턴스의 값을 새로운 인스턴스에 복제하기 위해 clone 메서드를 사용합니다.\n\n\nclone() 재정의 방법\n  - clone() 메서드를 사용하려면 먼저 Cloneable을 구현해야 합니다.\n  - 그리고 clone() 메서드를 오버라이딩 해줍니다.\n  - 접근 제어자를 protected 에서 public으로 변경해 줍니다.\n  - Object 반환 타입을 해당 객체의 타입으로 변경합니다.(공변 반환타입)\n  - CloneNotSupportedException을 적절하게 처리합니다.\n\n  class Color implements Cloneable {\n      ...\n      @Override \n      public Color clone() {\n          try {\n              return (Color) super.clone();\n          } catch (CloneNotSupportedException e) {\n              throw new AssertionError();\n          }\n      }\n  }\n\n\n\n  \n  \n    clone()을 사용하면 복제본을 변경하여도 원본의 값이 변경되지 않습니다.\n\n    Color originColor = Color.of(&quot;blue&quot;);\nColor copyColor = originColor.clone();\ncopyColor.changeColor(&quot;sky&quot;);\n// 결과 : originColor = blue, copyColor = sky\n    \n  \n  \n    배열에서는 일반적으로 같은 길이의 새로운 배열을 생성한 후 System.arraycopy()로 복사하지만, clone()을 이용하면 간단하게 복사할 수 있습니다.\n\n    int[] numbers = {1, 2, 3, 4, 5};\n\nint[] copyArr = new int[numbers.length];\nSystem.arraycopy(numbers, 0, copyArr, 0, numbers.length);\n  \nint[] cloneArr = numbers.clone();\n    \n  \n\n\n얕은 복사\n\n  하지만 clone()은 객체에 저장된 값을 그대로 복제할 뿐, 객체가 참조하고 있는 객체까지 복제하지는 않습니다.\n  기본형 배열인 경우에는 아무런 문제가 없지만, 객체배열을 clone()으로 복제하는 경우에는 원본과 복제본이 같은 객체를 공유하므로 완전한 복제하고 보기 어렵습니다.\n  \n    이러한 복제(복사)를 얕은 복사라고 합니다. 얕은 복사에서는 원본을 변경하면 복사본도 영향을 받습니다.\n\n    @ToString\n@AllArgsConstructor\nclass Point implements Cloneable {\n    private int x;\n    private int y;\n\n    @Override\n    public Point clone() {\n        try {\n            return (Point) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n    \n    @ToString\n@AllArgsConstructor\nclass Circle implements Cloneable {\n    private Point p;\n    private double r;\n\n    @Override\n    public Circle clone() {\n        try {\n            return (Circle) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n    \n\n    \n      \n        clone 메서드로 Circle 인스턴스를 복제하더라도 Circle에서 참조하고 있는 Point 객체까지 복제되지는 않습니다.\n\n        Circle origin = new Circle(new Point(1, 1), 2.0);\nCircle copy = circle.clone();\n      \ncopy.p.x = 9;\ncopy.p.y = 9;\n    \n// origin = (p=Point(x=9, y=9), r=2.0)\n// copy = (p=Point(x=9, y=9), r=2.0)\n        \n      \n    \n  \n\n\n깊은 복사\n\n  깊은 복사는 원본이 참조하고 있는 객체까지 복제하는 것입니다.\n  원본과 복사본이 서로 다른 객체를 참조하기 때문에 원본(또는 복사본)을 변경해도 다른 쪽에 영향을 미치지 않게 됩니다.\n    \n      \n    \n\n      @ToString\n  @AllArgsConstructor\n  class Circle implements Cloneable {\n      private Point p;\n      private double r;\n\n      @Override\n      public Circle clone() {\n          Object obj;\n          try {\n              obj = super.clone();\n          } catch (CloneNotSupportedException e) {\n              throw new AssertionError();\n          }\n\n          Circle c = (Circle) obj;\n          c.p = new Point(this.p.x, this.p.y);  // 참조 객체를 새로운 인스턴스로 생성\n          return c;\n      }\n}\n    \n\n    \n      \n        clone 메서드로 Circle 인스턴스를 복제할 때 참조하고 있는 Point 객체까지 새로운 인스턴스로 복제합니다.\n\n        Circle origin = new Circle(new Point(1, 1), 2.0);\nCircle copy = circle.clone();\n        \ncopy.p.x = 9;\ncopy.p.y = 9;\n      \n// origin = (p=Point(x=1, y=1), r=2.0)\n// copy = (p=Point(x=9, y=9), r=2.0)\n        \n      \n    \n  \n\n\n방어적 복사\n\n  방어적 복사란 외부와 내부에서 주소값을 공유하는 인스턴스의 관계를 끊어주기 위해 사용하는 복사 방식입니다.\n    \n      생성자를 통해를 초기화 할 때, 새로운 객체로 감싸서 복사해 주는 방법\n        public Period(Date start, Date end) {\n    this.start = new Date(start.getTime()); // 방어적 복사\n    this.end = new Date(end.getTime());     // 방어적 복사\n    if (validation(this.start, this.end)) {\n        throw new IllegalArgumentException(&quot;&quot;);\n    }\n}\n        \n      \n      값을 반환할 때, 변경되지 못하도록 객체의 복사본을 반환하는 방법\n        class Palette implements Cloneable {\n    private final List&amp;lt;Color&amp;gt; colors;\n    ...\n    public List&amp;lt;Color&amp;gt; unmodifiable() {\n        return Collections.unmodifiableList(colors); // 방어적 복\n    }\n}\n        \n        List&amp;lt;Color&amp;gt; unmodifiable = palette.unmodifiable();\nunmodifiable.add(Color.of(&quot;orange&quot;)); // UnsupportedOperationException 발생!\n        \n      \n    \n  \n\n\n\n   Reference\n   [Effective Java] 13.clone 재정의는 주의해서 진행하라\n   [Java] 방어적 복사(Defensive copy)\n   [얕은복사 / 깊은복사] 방어적 복사란 ?\n\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (7) 고급 매핑 - 복합키",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/04/25/jpa-7-2/",
    "date"     : "April 25, 2022",
    "excerpt"  : "✓︎ 복합키와 식별 관계 매핑\n    1) 식별 관계 vs 비식별 관계\n    2) 복합키: 비식별 관계 매핑\n    3) 복합키: 식별 관계 매핑\n    4) 비식별 관계로 구현\n    5) 일대일 식별 관계\n    6) 식별, 비식별 관계의 장단점\n\n복합키와 식별 관계 매핑\n복합키는 두 개 이상의 컬럼을 조합하여 기본키 역할을 할 수 있게 만든 키를 뜻한다.\n예를들어 동물원은 많지만 서울광진구에있는 동물원은 하나인것처럼 2개 이상의 기...",
    "content"  : "✓︎ 복합키와 식별 관계 매핑\n    1) 식별 관계 vs 비식별 관계\n    2) 복합키: 비식별 관계 매핑\n    3) 복합키: 식별 관계 매핑\n    4) 비식별 관계로 구현\n    5) 일대일 식별 관계\n    6) 식별, 비식별 관계의 장단점\n\n복합키와 식별 관계 매핑\n복합키는 두 개 이상의 컬럼을 조합하여 기본키 역할을 할 수 있게 만든 키를 뜻한다.\n예를들어 동물원은 많지만 서울광진구에있는 동물원은 하나인것처럼 2개 이상의 기준이 되었을경우에 식별이 가능한 값들이 있다.\n\n1) 식별 관계 vs 비식별 관계\n데이터베이스 테이블 사이의 관계는 외래키가 기본키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분한다.\n\n\n  식별 관계 : 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본키 + 외래키로 사용하는 관계\n  비식별 관계 : 부모 테이블의 기본 키를 받아서 자식 테이블의 외래키로만 사용하는 관계\n    \n      비식별 관걔는 외래키에 NULL을 허용하는지에 따라 필수적 비식별 관계와 선택적 비식별 관계로 구분한다.  식    필수적 비식별 관계(Mendatory) : 외래키에 NULL을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.\n선택적 비식별 관계(Optional) : 외래키에 NULL을 허용한다. 연관관계를 맺을지 선택할 수 있다.\n    \n  \n  최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세다.\n  \n\n\n2) 복합키: 비식별 관계 매핑\n\n  \n    기본키\n\n    @Entity\npublic class Hello {\n\t@Id\n\tprivate String id;\n}\n    \n  \n  복합 기본키\n    \n      다음과 같이 사용하면 매핑 예외가 발생한다.\n      복합키에는 @GenerateValue를 사용할 수 없다. 복합키를 구성하는 여러 컬럼 중 하나에도 사용할 수 없다.\n      \n    \n\n    @Entity\npublic class Hello {\n    @Id\n    private String id1;\n    @Id\n    private String id2;  // 실행 시점에 매핑 예외 발생\n}\n    \n\n    JPA는 영속성 컨텍스트에 엔티티를 보관할 때 엔티티의 식별자를 키로 사용한다. 그리고 식별자를 구분하기 위해 equals와 hashCode를 사용해서 동등성 비교를 한다. 그런데 식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고 그곳에 equals와 hashCode를 구현해야 한다.\n\n    JPA는 복합키를 지원하기 위해 @IdClass와 @EmbeddedId 2가지 방법을 제공한다.\n@IdClass가 데이터베이스에 맞춘 방법이라면 @EmbeddedId는 좀 더 객체지향적인 방법이다.\n\n    \n  @IdClass\n  \n        \n          부모 클래스\n            @Entity\n@IdClass(ParentId.class)\npublic class Parent {\n    @Id @Column(nema = &quot;PATRENT_ID1&quot;)\n    private String id1;  // 식별자 클래스의 ParentId.id1 과 연결\n    @Id @Column(nema = &quot;PATRENT_ID2&quot;)\n    private String id2;  // 식별자 클래스의 ParentId.id2 와 연결\n    private String name;\n    ...\n}\n            \n          \n          식별자 클래스\n            public class ParentId implements Serializable {\n    private String id1;\n    private String id2;\n      \t\n    public ParentId() { }\n      \n    public ParentId(String id1, String id2) {\n        this.id1 = id1;\n        this.id2 = id2;\n    }\n      \n    @Override\n    public boolean equals(Object o) { ... }\n      \n    @Override\n    public int hashCode() { ... }\n}\n            \n\n            식별자 클래스는 다음 조건을 만족해야 한다.\n- 식별자 클래스의 속성명과 엔티티 클래스에서 사용하는 식별자의 속성명이 같아야 한다.\n- Serializable 인터페이스를 구현해야 한다.\n- equals, hashCode를 구현해야 한다.\n- 기본 생성자가 있어야 한다.\n- 식별자 클래스는 public이어야 한다.\n\n            \n              \n              자식 클래스\n                public class Child {\n    @Id\n    private String id;\n        \n    @ManyToOne\n    @JoinColumns({\n        @JoinColumn(name = &quot;PARENT_ID1&quot;, referencedColumnName = &quot;PARERNT_ID1&quot;),\n        @JoinColumn(name = &quot;PARENT_ID2&quot;, referencedColumnName = &quot;PARERNT_ID2&quot;),\n    })\n    private Parent parent;\n}\n                \n              \n            \n          \n        \n      \n  \n\n    \n  @EmbeddedId\n  \n        \n          부모 클래스\n            @Entity\npublic class Parent {\n    @EmbeddedId\n    private ParentId parentId;\n    private String name;\n    ...\n}\n            \n          \n          식별자 클래스\n            @Embeddable\npublic class ParentId implements Serializable {\n    @Column(name = &quot;PARENT_ID1&quot;)\n    private String id1;\n    @Column(name = &quot;PARENT_ID2&quot;)\n    private String id2;\n      \t\n    public ParentId() { }\n      \n    public ParentId(String id1, String id2) {\n        this.id1 = id1;\n        this.id2 = id2;\n    }\n      \n    @Override\n    public boolean equals(Object o) { ... }\n      \n    @Override\n    public int hashCode() { ... }\n}\n            \n\n            \n              @IdClass와는 다르게 식별자 클래스에 기본키를 직접 매핑한다.\n            \n\n            식별자 클래스는 다음 조건을 만족해야 한다.\n- @Embeddable 어노테이션을 붙여주어야 한다.\n- Serializable 인터페이스를 구현해야 한다.\n- equals, hashCode를 구현해야 한다.\n- 기본 생성자가 있어야 한다.\n- 식별자 클래스는 public이어야 한다.\n          \n        \n      \n  \n  \n  \n\n\n▪ 복합키와 equals(), hashCode()\n\n복합키는 equals()와 hashCode()를 필수로 구현해야 한다.\nParentId id1 = new ParentId();\nid1.setId1(&quot;myId1&quot;);\nid1.setId2(&quot;myId2&quot;);\n\nParentId id2 = new ParentId();\nid2.setId1(&quot;myId1&quot;);\nid2.setId2(&quot;myId2&quot;);\n\n\nid1.equals(id2) 는 참일까 거짓일까?  \n  equals()를 적절히 오버라이딩했다면 참이겠지만 equals()를 적절히 오버라이딩 하지 않았다면 결과는 거짓이다. equals()는 인스턴스 참조값 비교인 == 비교(동일성 비교)를 하기 때문이다.\n\n\n  \n\n\n▪︎ @IdClass vs @EmbeddedId\n\n  @IdClass와 @EmbeddedId는 각각 장단점이 있으므로 취향에 맞는 것을 사용하면 된다.\n  @EmbeddedId가 @IdClass와 비교해서 더 객체지향적이고 중복도 없어서 좋아보이긴 하지만 특정 상황에 JPQL이 조금 더 길어질 수 있다.\n\n\nem.createQuery(&quot;select p.id.id1, p.id.id2 from Parent p&quot;);  // @EmbeddedId\nem.createQuery(&quot;select p.id1, p.id2 from Parent p&quot;);  // @IdClass\n\n\n\n  \n\n\n3) 복합키: 식별 관계 매핑\n\n\n\n  식별 관계에서 자식 테이블은 부모 테이블의 기본 키를 포함해서 복합키를 구성해야 하므로 @IdClass나 @EmbeddedId를 사용해서 식별자를 매핑해야 한다.\n  식별 관계는 기본키와 외래키를 같이 매핑해야 한다.\n  \n    식별자 매핑인 @Id와 연관관계 매핑인 @ManyToOne을 같이 사용하면 된다.\n\n    \n  @IdClass\n  \n        \n          부모 클래스\n            @Entity\npublic class Parent {\n    @Id @Column(name = &quot;PARENT_ID&quot;)\n    private ParentId id;\n    private String name;\n    ...\n}\n            \n          \n          자식 클래스\n            @Entity\n@IdClass(ChildId.class)\npublic class Child {\n    @Id                              // 기본키 매핑\n    @ManyToOne                       // 외래키 매핑\n    @JoinColumn(name = &quot;PARENT_ID&quot;)  // 외래키 매핑\n    public Parent parent;\n      \n    @Id @Column(name = &quot;CHILD_ID&quot;)\n    private String childId;\n      \n    private String name;\n    ...\n}\n            \n          \n          Child 식별자 클래스\n            public class ChildId implements Serializable {\n    private String parent;  // Child.parent 매핑\n    private String childId;  // Child.childId 매핑\n      \n    // equals, hashCode\n    ...\n}\n            \n          \n          손자 클래스\n            @Entity\n@IdClass(GrandChildId.class)\npublic class GrandChild {\n    @Id                                  // 기본키 매핑\n    @ManyToOne                           // 외래키 매핑\n    @JoinColumns({                       // 외래키 매핑\n            @JoinColumn(name = &quot;PARENT_ID&quot;),\n            @JoinColumn(name = &quot;CHILD_ID&quot;)\n    })\n    public Child child;\n      \n    @Id @Column(name = &quot;GRANDCHILD_ID&quot;)\n    private String id;\n      \n    private String name;\n    ...\n}\n            \n          \n          GrandChild 식별자 클래스\n            public class GrandChildId implements Serializable {\n    private ChildId child;  // GrandChild.child 매핑\n    private String id;  // GrandChild.id 매핑\n      \n    // equals, hashCode\n    ...\n}\n            \n          \n        \n      \n  \n\n    \n  @EmbeddedId\n  \n        \n          @EmbeddedId로 식별 관계를 구성할 때는 @MapsId를 사용해야 한다.\n          @MapsId는 외래키와 매핑한 연관관계를 기본키에도 매핑하겠다는 뜻이다.\n          \n            @MapsId의 속성값은 @EmbeddedId를 사용한 식별자 클래스의 기본키 필드를 지정하면 된다.\n          \n          부모 클래스\n            @Entity\npublic class Parent {\n    @Id @Column(name = &quot;PARENT_ID&quot;)\n    private ParentId id;\n    private String name;\n    ...\n}\n            \n          \n          자식 클래스\n            @Entity\npublic class Child {\n    @EmbeddedId\n    public ChildId id;\n      \n    @MapsId(&quot;parentId&quot;)  // ChildId.parentId 매핑\n    @ManyToOne\n    @JoinColumn(name = &quot;PARENT_ID&quot;)\n    public Parent parent;\n      \n    private String name;\n    ...\n}\n            \n          \n          Child 식별자 클래스\n            @Embeddable\npublic class ChildId implements Serializable {\n    private String parentId;  // @MapsId(&quot;parentId&quot;)로 매핑\n    @Column(name = &quot;CHILD_ID&quot;)\n    private String id;\n      \n    // equals, hashCode\n    ...\n}\n            \n          \n          손자 클래스\n            @Entity\npublic class GrandChild {\n    @EmbeddedId\n    private GrandChildId id;\n      \n    @MapsId(&quot;childId&quot;)  // GrandChildId.childId 매핑\n    @ManyToOne                    \n    @JoinColumns({\n            @JoinColumn(name = &quot;PARENT_ID&quot;),\n            @JoinColumn(name = &quot;CHILD_ID&quot;)\n    })\n    public Child child;\n      \n    private String name;\n    ...\n}\n            \n          \n          GrandChild 식별자 클래스\n            @Embeddable\npublic class GrandChildId implements Serializable {\n    private ChildId childId;  // @MapsId(&quot;childId&quot;)로 매핑\n    @Column(name = &quot;GRANDCHILD_ID&quot;)\n    private String id;\n      \n    // equals, hashCode\n    ...\n}\n            \n          \n        \n      \n  \n  \n  \n\n\n4) 비식별 관계로 구현\n식별관계의 복합키 클래스를 만들지 않아도 되므로 매핑도 쉽고 코드도 단순하다.\n// 부모\n@Entity\npublic class Parent {\n\t@Id @GeneratedValue\n\t@Column(name = &quot;PARENT_ID&quot;)\n\tprivate Long id;\n\tprivate String name;\n\t...\n}\n\n// 자식\n@Entity\npublic class Child {\n\t@Id @GeneratedValue\n\t@Column(name &quot;CHILD_ID&quot;)\n\tprivate Long id;\n\tprivate String name;\n\t\n\t@ManyToOne\n\t@JoinColumn(name = &quot;PARENT_ID&quot;)\n\tprivate Parent parent;\n\t...\n}\n\n// 손자\n@Entity\npublic class GrandChild {\n\t@Id @GeneratedValue\n\t@Column(name = &quot;GRANDCHILD_ID&quot;)\n\tprivate Long id;\n\tprivate String name;\n\t\n\t@ManyToOne\n\t@JoinColumn(name = &quot;CHILD_ID&quot;)\n\tprivate Child child;\n\t...\n}\n\n\n\n  \n\n\n5) 일대일 식별 관계\n\n\n\n  일대일 식별 관계는 자식테이블의 기본키 값으로 부모 테이블의 기본키 값만 사용하면 된다.\n  식별자가 단순히 컬럼 하나면 @MapsId를 사용하고 속성값은 비워두면 된다.\n    \n      \n        이때 @MapsId는 @Id를 사용해서 식별자로 지정한 컬럼과 매핑된다.\n\n          // 부모\n  @Entity\n  public class Board {\n  @Id @GeneratedValue\n  @Column(name = &quot;BOARD_ID&quot;)\n  private Long id;\n        \n      private String title;\n        \t\n      @OneToOne(mappedBy = &quot;board&quot;)\n      private BoardDetail boardDetail;\n      ...\n  }\n        \n  // 자식\n  @Entity\n  public class BoardDetail {\n  @Id\n  private Long boardId;\n        \n      @MapsId  // BoardDetail.boardId 매핑\n      @OneToOne\n      @JoinColumn(name = &quot;BOARD_ID&quot;)\n      private Board board;\n        \t\n      private String content;\n      ...\n  }\n        \n      \n    \n  \n  \n\n\n6) 식별, 비식별 관계의 장단점\n\n✓ 데이터베이스 설계 관점\n\n  데이터베이스 설계 관점에서 식별관계 보다 비식별 관계를 선호한다.\n    \n      식별 관계는 부모 테이블의 기본키를 자식 테이블로 전파하면서 자식 테이블의 기본키 컬럼이 점점 늘어난다.\n      식별 관계는 2개 이상의 컬럼을 합해서 복합 기본키를 만들어야 하는 경우가 많다.\n      반면에 비식별 관계의 기본키는 비즈니스와 전혀 관계없는 대리키를 주로 사용한다.\n    \n  \n\n\n✓ 객체 관계 매핑 관점\n\n  객체 관계 매핑의 관점에서 비식별 관계를 선호한다.\n    \n      일대일 관계를 제외하고 식별 관계는 2개 이상의 컬럼을 묶은 복합 기본키를 사용한다.\n      JPA에서 복합키는 별도의 복합키 클래스를 만들어서 사용해야 한다. 컬럼이 하나인 기본키를 매핑하는 것보다 많은 노력이 필요하다.\n      비식별 관계의 기본키는 주로 대리키를 사용하는데 JPA는 @GenerateValue처럼 대리키를 생성하기 위한 편리한 방법을 제공한다.\n    \n  \n\n\n✓ 식별 관계의 장점\n\n  기본키 인덱스를 활용하기 좋다.\n  상위 테이블의 기본키 컬럼을 자식, 손자, 테이블들이 가지고 있으므로 특정 상황에 조인 없이 하위 테이블만으로 검색을 완료할 수 있다.\n\n\n✓ ORM 신규 프로젝트 진행시 추천하는 방법\n\n  될 수 있으면 비식별 관계를 사용하자.\n  기본키는 Long 타입의 대리키를 사용하자.\n    \n      대리키는 비즈니스와 아무 관련이 없기 때문에 비즈니스가 변경되어도 유연한 대처가 가능하다.\n      JPA에서는 @GenerateValue를 통해 간편하게 대리키를 생성할 수 있다.\n    \n  \n  선택적 비식별 관계보다는 필수적 비식별 관계를 사용하는 것이 좋다.\n    \n      선택적인 비식별 관계는 NULL을 허용하므로 조인할  때에 외부 조인을 사용해야 한다.\n      반면에 필수적 비식별 관계는 NOT NULL로 항상 관계가 있다는 것을 보장하므로 내부 조인만 사용해도 된다.\n    \n  \n\n\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (7) 고급 매핑 - 상속관계 매핑",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/04/22/jpa-7-1/",
    "date"     : "April 22, 2022",
    "excerpt"  : "✓︎ 상속 관계 매핑\n✓︎ @MappedSuperclass\n\n1. 상속 관계 매핑\n데이터베이스에는 상속이라는 개념이 없다.\n그래서 데이터베이스에서 상속과 유사한 슈퍼타입-서브타입 관계를 매핑하는 것으로 생각하면 된다.\n슈퍼타입-서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법을 선택할 수 있다.\n\n① 각각 테이블로 변환 → 조인 전략!\n② 통합 테이블로 변환 → 단일 테이블 전략!\n③ 서브타입 테이블로 변환 → 구현...",
    "content"  : "✓︎ 상속 관계 매핑\n✓︎ @MappedSuperclass\n\n1. 상속 관계 매핑\n데이터베이스에는 상속이라는 개념이 없다.\n그래서 데이터베이스에서 상속과 유사한 슈퍼타입-서브타입 관계를 매핑하는 것으로 생각하면 된다.\n슈퍼타입-서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법을 선택할 수 있다.\n\n① 각각 테이블로 변환 → 조인 전략!\n② 통합 테이블로 변환 → 단일 테이블 전략!\n③ 서브타입 테이블로 변환 → 구현 클래스마다 테이블 전략!\n\n1) 조인 전략\n\n\n\n  구현 방법\n    \n      엔티티 각각을 모두 테이블로 만든다.\n      \n        자식 테이블이 부모 테이블의 기본키를 받아서 기본키 + 외래키로 사용한다.\n\n        @Entity\n@Inheritance(strategy = InheritanceType.JOINED) // 자식 클래스 매핑 전략\n@DiscriminatorColumn(name = &quot;DTYPE&quot;) // 자식 클래스 구분 컬럼\npublic abstract class Item {\n    ...\n}\n      \n@Entity\n@DiscriminatorValue(&quot;A&quot;) // 구분 컬럼 값\npublic class Album extends Item {  ...  }\n      \n@Entity\n@DiscriminatorValue(&quot;B&quot;)\n@PrimaryKeyJoinColumn(name = &quot;BOOK_ID&quot;) // 부모 컬럼의 기본키 컬럼명 재정의\npublic class Book extends Item {  ...  }\n        \n      \n      \n    \n  \n  주의 할 점\n    \n      타입을 구분하는 컬럼을 추가해야 한다.\n      \n    \n  \n  조인 전략의 장단점\n    \n      장점\n        \n          테이블이 정규화 된다.\n          외래키 참조 무결성 제약조건을 활용할 수 있다.\n          저장공간을 효율적으로 사용한다.\n        \n      \n      단점\n        \n          조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다.\n          조회 쿼리가 복잡하다.\n          등록할 때 INSERT SQL을 2번 실행한다.\n        \n      \n    \n  \n\n\n\n\n2) 단일 테이블 전략\n\n\n\n  구현 방법\n    \n      테이블을 하나만 사용한다.\n      \n        구분 컬럼으로 자식 데이터를 구분한다.\n\n        @Entity\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 자식 클래스 매핑 전략\n@DiscriminatorColumn(name = &quot;DTYPE&quot;) // 자식 클래스 구분 컬럼\npublic abstract class Item {\n    ...\n}\n      \n@Entity\n@DiscriminatorValue(&quot;A&quot;) // 구분 컬럼 값\npublic class Album extends Item {  ...  }\n      \n@Entity\n@DiscriminatorValue(&quot;B&quot;)\n@PrimaryKeyJoinColumn(name = &quot;BOOK_ID&quot;) // 부모 컬럼의 기본키 컬럼명 재정의\npublic class Book extends Item {  ...  }\n        \n      \n      \n    \n  \n  주의할 점\n    \n      자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.\n      \n    \n  \n  장단점\n    \n      장점\n        \n          조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.\n          조회 쿼리가 단순하다.\n        \n      \n      단점\n        \n          자식 엔티티가 매핑한 컬럼 모두 null을 허용해야 한다.\n          단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그래서 상황에 따라 조회 성능이 더 느려질 수도 있다.\n        \n      \n    \n  \n\n\n\n\n3) 구현 클래스마다 테이블 전략\n\n\n\n  구현 방법\n    \n      자식 엔티티마다 테이블을 만든다.\n      \n        자신 테이블 각각에 필요한 컬럼을 모두 넣는다.\n\n        @Entity\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // 자식 클래스 매핑 전략\npublic abstract class Item {\n    ...\n}\n      \n@Entity\npublic class Album extends Item {  ...  }\n      \n@Entity\npublic class Book extends Item {\t...  }\n        \n      \n      \n    \n  \n  특징\n    \n      구분 컬럼을 사용하지 않는다.\n      일반적으로 추천하지 않는 전략이다.\n      \n    \n  \n  장단점\n    \n      장점\n        \n          서브 타입을 구분해서 처리할 때 효과적이다.\n          not null 제약조건을 사용할 수 있다.\n        \n      \n      단점\n        \n          여러 자식 테이블을 함께 조회할 때 성능이 느리다. (UNION SQL을 사용해야 한다.)\n          자식 테이블을 통합해서 쿼리하기 힘들다.\n          \n        \n      \n    \n  \n\n\n구현 클래스마다 테이블 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않는 전략이니, 조인 전략이나 단일 테이블 전략을 고려하자.\n\n2. @MappedSuperclass\n부모 클래스와 자식 클래스를 매핑하지 않고, 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperclass를 사용하면 된다.\n@Entity는 실제 클래스와 매핑되지만 @MappedSuperclass는 실제 테이블과는 매핑되지 않는다.\n\n@MappedSuperclass\npublic abstract class BaseEntity {\n    @Id @GeneratedValue\n    private Long id;\n    private String name;\n    ...\n}\n\n@Entity\npublic class Member extends BaseEntity {\n    // id, name 컬럼 BaseEntity로 부터 상속됨\n    private String email;\n}\n\n@Entity\npublic class Seller extends BaseEntity {\n    // id, name 컬럼 BaseEntity로 부터 상속됨\n    private String shopName;\n}\n\n\n\n  BaseEntity에는 객체들이 주로 사용하는 공통 매핑 정보를 정의한다.\n    \n      등록일자, 수정일자, 등록자, 수정자 같은 공통으로 사용하는 속성을 효과적으로 관리할 수 있다.\n    \n  \n  \n    @AttributeOverride, @AttributeOverride를 사용하면 매핑 정보를 재정의 할 수 있다.\n\n      @Entity\n  @AttributeOverrides({\n  \t@AttributeOverride(name = &quot;id&quot;, column = @Column(name = &quot;MEMBER_ID&quot;)),\n  \t@AttributeOverride(name = &quot;name&quot;, column = @Column(name = &quot;MEMBER_NAME&quot;))\n  })\n  public class Member extends BaseEntity {  ...  }\n    \n  \n  \n    @AssociationOverride를 사용하면 연관관계를 재정의할 수 있다.\n  \n  특징\n    \n      @MappedSuperclass로 지정한 클래스는 엔티티가 아니므로 em.find()나 JPQL에서 사용할 수 없다.\n      이 클래스를 직접 생성해서 사용할 일은 거의 없으므로 추상 클래스로 만드는 것을 권장한다.\n    \n  \n\n\n\n"
} ,
  
  {
    "title"    : "그림으로 배우는 Http&amp;Network Basic - (1) TCP/IP",
    "category" : "Book",
    "tags" : "http",
    "url"      : "/book/2022/04/01/http-1/",
    "date"     : "April 1, 2022",
    "excerpt"  : "네트워크의 기본이 되는 TCP/IP 통신\nTCP/IP 계층\nTCP/IP 통신의 흐름\nIP 프로토콜\nTCP 프로토콜\n\n네트워크의 기본이 되는 TCP/IP 통신\n\n  프로토콜이란 서로 다른 하드웨어와 운영체제가 통신하기 위한 규칙이다.\n인터넷과 관련된 프로토콜들을 모은 것이 TCP/IP 이다.\n\n\n\n  \n\n\n\n\n\n  \n\n\nTCP/IP 계층\n\n  TCP/IP에서 중요한 개념 중 하나가 계층(Layer)이다.\n  TCP/IP의 4계층\n    \n ...",
    "content"  : "네트워크의 기본이 되는 TCP/IP 통신\nTCP/IP 계층\nTCP/IP 통신의 흐름\nIP 프로토콜\nTCP 프로토콜\n\n네트워크의 기본이 되는 TCP/IP 통신\n\n  프로토콜이란 서로 다른 하드웨어와 운영체제가 통신하기 위한 규칙이다.\n인터넷과 관련된 프로토콜들을 모은 것이 TCP/IP 이다.\n\n\n\n  \n\n\n\n\n\n  \n\n\nTCP/IP 계층\n\n  TCP/IP에서 중요한 개념 중 하나가 계층(Layer)이다.\n  TCP/IP의 4계층\n    \n      애플리케이션 계층\n유저에게 제공되는 애플리케이션에서 사용하는 통신\neg. FTP, DNS, HTTP 등\n      트랜스포트 계층\n네트워크로 접속되어 있는 컴퓨터 사이의 데이터 흐름을 제공\neg. TCP, UDP 등\n      네트워크 계층\n네트워크 상에서 패킷의 이동을 담당 (어떠한 경로를 거쳐 상대의 컴퓨터까지 패킷을 보낼지 결정)\n      링크 계층\n네트워크에 접속하는 하드웨어적인 측면\neg. 디바이스 드라이버, 네트워크 인터페이스 카드(NIC), 케이블 등\n    \n  \n  \n\n\n\n\n\n  \n\n\nTCP/IP 통신의 흐름\n\n\n\n  \n  클라이언트 ➡️ 애플리케이션 계층(HTTP Request) ➡️ 트랜스포트 계층(TCP) ➡️ 네트워크 계층(패킷) ➡️ 링크 계층(수신지 MAC 주소)\n  서버 ➡️ 링크 계층 ➡️ 네트워크 계층 ➡️️ 트랜스포트 계층 ➡️ 애플리케이션 계층\n  \n  \n\n\n\n\n  \n\n\n\n  헤더는 해당 계층에 필요한 정보이다. (TCP 헤더, IP 헤더, Ethernet 헤더)\n\n\n\n  송신측에서는 각 계층을 거칠 때는 헤더를 추가한다.\n  수신측에서는 각 계층을 거칠 때 마다 해당 계층에서 사용한 헤더를 삭제한다.\n  이렇게 정보(데이터)를 감싸는 것을 캡슐화라고 부른다.\n  \n\n\nIP 프로토콜\n\n  IP는 TCP/IP에서 네트워크 계층에 해당된다. (IP는 ‘IP 주소’가 아닌 프로토콜의 명칭)\n  IP의 역할은 개별 패킷을 수신측에 전달하는 것이다.\n    \n      패킷을 전달하기까지 여러 가지 요소가 필요한데, 그 중에서도 IP 주소와 MAC 주소가 중요하다.\n      IP 주소는 각 노드에 부여된 주소이다.\n      MAC 주소(Media Access Control Address)는 각 네트워크 카드에 할당된 고유의 주소이다.\n      IP 주소는 변경 가능하지만 기본적으로 MAC 주소는 변경할 수 없다.\n    \n  \n\n\nARP 프로토콜 \n인터넷에서 통신 상대가 같은 랜선 내에 있을 경우는 적어서 여러 대의 컴퓨터와 네트워크를 중계하기 위한 프로토콜이 필요하다.\nARP(Address Resolution Protocal)는 주소를 해결하기 위한 프로토콜 중 하나로, 수신지의 IP 주로를 바탕으로 MAC 주소를 조사할 수 있다.\n\n  \n\n\nTCP 프로토콜\n\n  TCP는 TCP/IP에서 트랜스포트 계층에 해당된다.\n  TCP는 신뢰성 있는 바이트 스트림 서비스를 제공한다.\n    \n      바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것이다.\n      TCP는 연결형으로, 순차적인 데이터를 안전하게 전송하는 프로토콜이다.\n      반면, UDP는 비연결형으로, 순차적이지 않은 데이터를 빠르게 전송하는 프로토콜이다.\n    \n  \n  TCP는 신뢰성을 보장하기 위해 3-Way-Handshaking 방법을 사용한다.\n    \n      3-Way-Handshaking은 SYN, ACK 플래그를 사용하여 연결 수립을 확인한다.\n      송신(SYN) ➡️️ 수신(SYN/ACK) ➡️️ 송신(ACK)️️\n    \n\n    \n  \n\n\n\n\n\n   Reference\n   웹과 네트워크의 기본(TCP/IP)\n   TCP/IP의 망 계층 구조 (4 계층 모델)\n\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (6) 다양한 연관관계 매핑",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/03/21/jpa-6/",
    "date"     : "March 21, 2022",
    "excerpt"  : "✓︎ 다대일\n✓︎ 일대다\n✓︎ 일대일[1:1]\n✓︎ 다대다[N:M]\n\n핵심 키워드\n\n\n  엔티티의 연관관계를 매핑할 때는 다음 3가지를 고려해야 한다.\n    \n      다중성\n      단방향, 양방향\n      연관관계의 주인\n    \n\n    \n  \n\n\n1. 다대일\n\n  다대일 관계의 반대 방향은 항상 일대다 관계이고, 일대다 관계의 반대 방향은 항상 다대일 관계이다.\n  데이터베이스 테이블의 일(1), 다(N) 관계에서 외래 키는...",
    "content"  : "✓︎ 다대일\n✓︎ 일대다\n✓︎ 일대일[1:1]\n✓︎ 다대다[N:M]\n\n핵심 키워드\n\n\n  엔티티의 연관관계를 매핑할 때는 다음 3가지를 고려해야 한다.\n    \n      다중성\n      단방향, 양방향\n      연관관계의 주인\n    \n\n    \n  \n\n\n1. 다대일\n\n  다대일 관계의 반대 방향은 항상 일대다 관계이고, 일대다 관계의 반대 방향은 항상 다대일 관계이다.\n  데이터베이스 테이블의 일(1), 다(N) 관계에서 외래 키는 항상 다 쪽에 있다.\n→ 따라서 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽이다.\n\n\n1) 다대일 단방향 [N:1]\n\n  @ManyToOne\n  @JoinColumn(name = &quot;TEAM_ID&quot;)  // Member.team 필드를 TEAM_ID 외래키와 매핑\n  private Team team;\n\n\n  \n\n\n2) 다대일 양방향 [N:1 - 1:N]\n\n  @ManyToOne\n  @JoinColumn(name = &quot;TEAM_ID&quot;)  // Member.team 필드를 TEAM_ID 외래키와 매핑\n  private Team team;\n\n\n  @OneToMany(mappedBy = &quot;team&quot;)\n  private List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;Member&amp;gt;();\n\n\n\n  양방향은 외래 키가 있는 쪽이 연관관계의 주인이다.\n    \n      일대다와 다대일 연관관계는 항상 다(N)에 외래 키가 있다.\n    \n  \n  양방향 연관관계는 항상 서로를 참조해야 한다.\n    \n      양방향 관계에서 객체가 항상 서로 참조하게 하려면 연관관계 편의 메소드를 사용하는 것이 좋다.\n      연관관계 편의 메소드는 한 곳에만 작성하거나 양쪽에 작성할 수 있는데, 양쪽에 작성할 경우 무한루프에 빠지므로 주의해야 한다. → 무한루프에 빠지지 않도록 검사하는 로직을 추가한다.\n      \n    \n\n    public void setTeam(Team team) {\n    this.team = team;\n    if (!team.getMembers().contains(this)) {  // 무한 루프에 빠지지 않도록 체크\n        team.getMembers().add(this); \n    }\n}\n    \n\n    public void addMember(Member member) {\n    this.members.add(member);\n    if (member.getTeam() != this) {  // 무한 루프에 빠지지 않도록 체크\n        members.setTeam(this);\n    } \n}\n    \n  \n  \n\n\n2. 일대다\n\n  일대다 관계는 다대일 관계의 반대 방향이다.\n  일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로, 자바 컬렉션을 사용해야 한다.\n\n\n1) 일대다 단방향 [1:N]\n\n  일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 한다.\n  @JoinColumn을 명시하지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑한다.\n\n\n\n\n  @OneToMany\n  @JoinColumn(name = &quot;TEAM_ID&quot;)  // Member 테이블의 TEAM_ID (FK)\n  private List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;Member&amp;gt;();\n\n\n\n  일대다 매핑의 단점\n    \n      매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다.\n→ 본인 테이블에 외래 키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 외래키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 한다.\n      일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자.\n    \n  \n  \n\n\n2) 일대다 양방향 [1:N - N:1]\n\n  일대다 양방향 매핑은 존재하지 않는다. 대신 다대일 양방향 매핑을 사용해야 한다.\n  더 정확히 말해서, 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다.\n관계형 데이터베이스의 특성상 일대다, 다대일 관계는 항상 다 쪽에 외래 키가 있다.\n따라서 @OneToMany, @ManyToOne 둘 중에 연관관계의 주인은 항상 다 쪽인 @ManyToOne을 사용한 곳이다.\n  빈면, 일대다 양방향 매핑에서 연관관계의 주인인 @ManyToOne에는 mappedBy 속성이 없다.\n\n\n\n\n\n  이 방법은 일대다 양방향 매핑이라기 보다는 일대다 단방향 매핑 반대편에 다대일 단방향 매핑을 읽기 전용으로 추가해서 일대다 양방향처럼 보이도록 하는 방법니다.\n  \n    이렇게 되면 둘 다 같은 키를 관리하므로 문제가 발생할 수 있으므로, 다대일 쪽에 insertable = false, updatable = false로 설정해서 읽기만 가능하게 한다.\n\n    @OneToMany\n@JoinColumn(name = &quot;TEAM_ID&quot;)  // Member 테이블의 TEAM_ID (FK)\nprivate List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;Member&amp;gt;();\n    \n    @ManyToOne\n@JoinColumn(name = &quot;TEAM_ID&quot;, insertable = false, updatable = false)\nprivate Team team;\n    \n  \n  \n\n\n3. 일대일[1:1]\n\n  일대일 관계는 그 반대도 일대일 관계다.\n  일대일 관계는 주 테이블이나 대상 테이블 둘 중 외래키를 선택할 수 있다.\n\n\n1) 주 테이블에 외래 키\n\n  일대일 관계를 구성할 때 객체지향 개발자들은 주 테이블에 외래 키가 있는 것을 선호한다.\n  이 방법은 주 테이블이 외래 키를 가지고 있으므로 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 알 수 있다.\n\n\n- 단방향\n\n  이 관계는 다대일 단방향(@ManyToOne)과 거의 비슷하다.\n\n\n\n  @OneToOne\n  @JoinColumn(name = &quot;LOCKER_ID&quot;)\n  private Locker locker;\n\n\n  \n\n\n- 양방향\n\n\n  일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 양방향으로 매핑한다.\n\n\n\n  @OneToOne\n  @JoinColumn(name = &quot;LOCKER_ID&quot;)\n  private Locker locker;\n\n  @OneToOne(mappedBy = &quot;locker&quot;)\n  private Member member;\n\n\n\n  \n\n\n2) 대상 테이블에 외래 키\n\n- 단방향\n\n\n  일대일 관계 중 대상 테이블에 외래 키가 있는 단방향 관계는 JPA에서 지원하지 않는다.\n    \n      단방향 관계를 Locker에서 Member 방향으로 수정하거나, 양방향 관계로 만들고 Locker를 연관관계의 주인으로 설정해야 한다.\n    \n  \n\n\n\n\n- 양방향\n\n\n  일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 양방향으로 매핑한다.\n\n\n\n\n  @OneToOne(mappedBy = &quot;member&quot;)\n  private Locker locker;\n\n  @OneToOne\n  @JoinColumn(name = &quot;MEMBER_ID&quot;)\n  private Member member;\n\n\n\n  \n\n\n프록시를 사용할 때 외래 키를 직접 관리하지 않는 일대일 관계는 지연 로딩으로 설정해도 즉시 로딩된다.\n여기서 Locker.member는 지연 로딩할 수 있지만, Member.locker는 지연 로딩으로 설정해도 즉시 로딩된다.\n\n\n  \n\n\n4. 다대다[N:M]\n\n\n\n  관계형 데이터베이스는 정규화돈 테이블 2개로 다대다 관계를 표현할 수 없다.\n→ 그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용한다.\n\n\n\n\n\n  객체는 테이블과 다르게 객체 2개로 다대다 관걔를 만들 수 있다.\n    \n      @ManyToMany를 사용하면 다대다 관계를 편리하게 매핑할 수 있다.\n    \n  \n\n\n\n\n1) 다대다 : 단방향\n\n  \n    @ManyToMany를 사용하면 복잡한 다대다 관계를 단순하게 사용할 수 있다.\n\n    @Entity\npublic class Member {\n    @Id @Column(name = &quot;MEMBER_ID&quot;)\n    private String id;\n  \n    private String username;\n  \n    @ManyToMany\n    @JoinTable(name = &quot;MEMBER_PRODUCT&quot;,\n            joinColumns = @JoinColumn(name = &quot;MEMBER_ID&quot;),\n            inverseJoinColumns = @JoinColumn(name = &quot;PRODUCT_ID&quot;))\n    private List&amp;lt;Product&amp;gt; products = new ArrayList&amp;lt;&amp;gt;();\n}\n    \n    \n      @JoinTable.name\n연결 테이블을 지정한다.\n      @JoinTable.joinColumns\n현재 방향인 회원과 매핑할 조인 컬럼 정보를 지정한다.\n      @JoinTable.inverseJoinColumns\n반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.\n      \n    \n\n    @Entity\npublic class Product {\n    @Id @Column(name = &quot;PRODUCT_ID&quot;)\n    private String id;\n}\n    \n  \n\n\n2) 다대다 : 양방향\n\n  \n    역방향에도 @ManyToMany를 사용하고, 양쪽 중 원하는 곳에 mappedBy로 연관관계의 주인을 지정한다.\n\n    @Entity\npublic class Product {\n    @Id @Column(name = &quot;PRODUCT_ID&quot;)\n    private String id;\n  \n    @ManyToMany(mappedBy = &quot;product&quot;)\n    private List&amp;lt;Member&amp;gt; members;\n}\n    \n  \n  \n\n\n3) 다대다 : 매핑의 한계와 극복, 연결 엔티티 사용\n\n  @ManyToMany를 사용하면 연결 테이블을 자동으로 만들어주어 편리하지만, 실무에서 사용하는데 한계가 있다.\n    \n      보통 연결 테이블에는 외래 키만 필요한 것이 아니라, 주문수량이나 주문한 날짜 같은 추가적인 컬림이 필요하다.\n      하지만 이렇게 컬럼을 추가하면 더는 @ManyToMany를 사용할 수 없다.\n    \n  \n\n\n\n\n\n  결국 연결 테이블을 매핑하는 연결 엔티티를 만들고 이곳에 추가한 컬럼들을 매핑해야 한다.\n    \n      엔티티 간의 관계도 다대다에서 일대다, 다대일 관계로 풀어햐 한다.\n    \n  \n\n\n\n\n\n  \n    회원상품 엔티티에서 기본 키를 매핑하는 @Id와 외래 키를 매핑하는 @JoinColumn을 사용해서 기본 키와 외래 키를 한번에 매핑했다.\n\n    @Entity\n@IdClass(MemberProductId.class)\npublic class MemberProduct {\n    @Id\n    @ManyToOne\n    @JoinColumn(name = &quot;MEMBER_ID&quot;)\n    private Member member;      // MemberProductId.member와 연결\n  \n    @Id\n    @ManyToOne\n    @JoinColumn(name = &quot;PRODUCT_ID&quot;)\n    private Product product;    // MemberProductId.product와 연결\n}\n    \n  \n  \n    JPA에서 복합 키를 사용하려면 별도의 식별자 클래스를 만들어야 한다.\n\n    public class MemberProductId implements Serializable {\n    private String member;   //MemberProduct.member와 연결\n    private String product;  //MemberProduct.product와 연결\n      \n    // Equals and HashCode\n    @Override\n    public boolean equals(Object o) { ... }\n  \n    @Override\n    public int hashCode() { ... }\n}\n    \n  \n  복합 기본 키\n    \n      회원상품 엔티티는 기본 키가 MEMBER_ID와 PRODUCT_ID로 이루어진 복합 기본키다.\n      복합 키를 위한 식별자 클래스의 특징\n        \n          복합 키는 별도의 식별자 클래스로 만들어야 한다.\n          Serializable을 구현해야 한다.\n          equals와 hashCode 메소드를 구현해야 한다.\n          기본 생성자가 있어야 한다.\n          식별자 클래스는 public이어야 한다.\n          @IdClass를 사용하는 방법 외에 @EmbeddedId를 사용하는 방법도 있다.\n        \n      \n    \n  \n  식별 관계\n    \n      회원상품은 회원과 상품의 기본 키를 받아서 자신의 기본 키로 사용한다. 이렇게 부모 테이블의 기본 키를 받아서 자신의 기본 키 + 외래 키로 사용하는 것을 데이터베이스 용어로 식별 관계라고 한다.\n    \n  \n  \n\n\n4) 다대다 : 새로운 기본 키 사용\n\n  기본 키 생성 전략은 데이터베이스에서 자동으로 생성해 주는 대리 키를 Long 값으로 사용하는 것을 추천한다.\n    \n      연결 테이블에 새로운 기본 키 ORDER_ID를 추가한다.\n    \n  \n\n\n\n\n5) 다대다 연관관계 정리\n\n  다대다 관계를 일대다 다대일 관계로 풀어내기 위해 연결 테이블을 만들 때 식별자를 어떻게 구성할지 선택해야 한다.\n    \n      식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용한다.\n      비식별 관계 : 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다.\n    \n  \n\n\n\n\n\n   Reference\n   [JPA] 다양한 연관관계 매핑\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (5) 연관관계 매핑 기초",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/03/08/jpa-5/",
    "date"     : "March 8, 2022",
    "excerpt"  : "✓︎ 단방향 연관관계\n✓︎ 연관관계 사용\n✓︎ 양방향 연관관계\n✓︎ 연관관계의 주인\n✓︎ 양방향 연관관계 저장\n✓︎ 양방향 연관관계의 주의점\n\n핵심 키워드\n\n\n  방향 : 단방향, 양방향이 있다.\n  한 쪽이 어느 한 쪽만 참조하는 → 단방향 관계\n  양쪽 모두 서로를 참조하는 것 → 양방향 관계\n  방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.\n  다중성 : 다대일(N:1), 일대다(1:N), 다대다(N:N) 다중성이 있다...",
    "content"  : "✓︎ 단방향 연관관계\n✓︎ 연관관계 사용\n✓︎ 양방향 연관관계\n✓︎ 연관관계의 주인\n✓︎ 양방향 연관관계 저장\n✓︎ 양방향 연관관계의 주의점\n\n핵심 키워드\n\n\n  방향 : 단방향, 양방향이 있다.\n  한 쪽이 어느 한 쪽만 참조하는 → 단방향 관계\n  양쪽 모두 서로를 참조하는 것 → 양방향 관계\n  방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.\n  다중성 : 다대일(N:1), 일대다(1:N), 다대다(N:N) 다중성이 있다.\n  관계의 주인 : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.\n\n\n1. 단방향 연관관계\n\n  다대일(N:1) 단방향 관계\n    \n      회원(Member) - 팀(Team)\n      회원은 하나의 팀에만 소속될 수 있다. → 다대일(N:1) 관계\n\n      회원 객체는 Member.team 필드로 팀 객체와 연관관계를 맺는다. 반대로 팀은 회원을 알 수 없다.\n      회원 테이블은 TEAM_ID 외래키로 팀 테이블과 연관관계를 맺는다.\n      \n    \n\n    참조를 통한 연관관계는 언제나 단방향이다.\n테이블을 통한 연관관계는 언제나 양방향이다.\n그렇다면 객체 간의 양방향 관계는?\n  객체 간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다.\n  (정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단반향 관계 2개이다.)\n  \n\n\n객체 연관관계 vs 테이블 연관관계 정리\n\n\n  \n    참조를 사용하는 객체의 연관관계는 단방향이다.\nA → B (a.b)\n  \n  \n    외래 키를 사용하는 테이블의 연관관계는 양방향이다.\nA JOIN B 가 가능하면 반대로 B JOIN A 도 가능\n  \n  \n    객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.\nA → B (a.b)\nB → A (b.a)\n  \n\n\n1) 순수한 객체 연관관계\n\n  객체 탐색 그래프: 객체는 참조를 사용해서 연관관계를 탐색할 수 있다.\n    Team team = memer1.getTeam();\n    \n  \n  \n\n\n\n\n2) 테이블 연관관계\n\n  데이터베이스는 외래 키를 사용해서 연관관계를 탐색할 수 있는데 이것을 조인이라 한다.\n    SELECT T.*\nFROM MEMBER M\nJOIN TEAM T ON M.TEAM_ID = T.TEAM_ID\nWHERE M.MEMBER_ID = &#39;memeber1&#39;\n    \n  \n\n\n3) 객체 관계 매핑\n\n  JPA를 통한 연관 관계 매핑\n    \n      객체 연관관계 : 회원 객체의 Member.team 필드를 사용\n      테이블 연관관계 : 회원 테이블의 MEMBER.TEAM_ID 외래 키 컬럼을 사용\n    \n\n    @ManyToOne\n@JoinColumn(name = &quot;TEAM_ID&quot;)\nprivate Team team;\n    \n  \n\n\n4) @JoinColumn\n\n\n\n  @JoinColumn 을 생략하면 외래 키를 찾을 때 기본 전략을 사용한다.\n    \n      기본 잔략 : 필드명 + _ + 참조하는 테이블의 컬럼명\n    \n  \n\n\n5) @ManyToOne\n\n\n\n  다대일(@ManyToOne)과 비슷한 일대일(@OneToOne) 관계도 있다. 단방향 관계를 매핑할 때 둘 중 어떤 것을 사용해야 할지는 반대편 관계에 달려 있다.\n    \n      일대다(1:N) ↔︎ 다대일(N:1) / 일대일(1:1) ↔ 일대일(1:1)\n    \n  \n\n\n2. 연관관계 사용\n\n1) 저장\n\n  회원 엔티티가 팀 엔티티를 참조하여 저장한다.\n    void testSave() {\nTeam team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;);\nem.persist(team1);  //연관된 엔티티는 영속 상태여야 함\n  \n    Member member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;);\n    member1.setTeam(team1);  //연관관계 설정 (member1 -&amp;gt; team1)\n    em.persist(member1);\n}\n    \n  \n\n\n📍 JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.\n\n2) 조회\n\n  연관관계가 있는 엔티티를 조회하는 방법은 크게 2가지이다.\n    \n      객체 그래프 탐색(객체 연관관계를 사용한 조회)\n          Member member = em.find(Member.class, &quot;member1&quot;);\n  Team team = member.getTeam();\n        \n      \n      객체지향 쿼리(JPAL) 사용\n          String jpql = &quot;select m from Member m join m.team t where t.name = :teamName&quot;;\n  List&amp;lt;Member&amp;gt; result = em.createQuery(jpql, Member.class)\n                      .setParameter(&quot;teamName&quot;, &quot;팀1&quot;)\n                      .getResultList();\n        \n      \n    \n  \n\n\n3) 수정\n\n  \n    단순히 불러온 엔티티의 값만 변경하면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동한다. em.update() 와 같은 메소드는 없다.\n\n    Member member = em.find(Member.class, &quot;member1&quot;);\nmember.setTeam(team2);\n    \n  \n\n\n4) 연관관계 제거\n\n  연관관계를 null 로 설정한다.\n    Member member = em.find(Member.class, &quot;member1&quot;);\nmember.setTeam(null);  //연관관계 제거\n    \n  \n\n\n5) 연관된 엔티티 삭제\n\n\n  연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다.\n    membe1.setTeam(null);  //연관관계 제거\nem.remove(team1);  //팀 삭제\n    \n  \n\n\n3. 양방향 연관관계\n\n1) 양방향 연관관계 매핑\n\n  일대다(1:N) 관계는 여러 건과 연관관계를 맺을 수 있으므로 컬렉션을 사용해야 한다.\n    \n      Mamber.clss\n        @ManyToOne\n@JoinColumn(name = &quot;TEAM_ID&quot;)\nprivate Team team;\n        \n      \n      Team.class\n        @OneToMany(mappedBy = &quot;team&quot;)\nprivate List&amp;lt;Member&amp;gt; members = new ArrayList&amp;lt;&amp;gt;();\n        \n      \n    \n  \n\n\n2) 일대다 컬렉션 조회\n\n  객체 그래프 탐색을 사용\n    Team team = em.find(Team.class, &quot;team1&quot;);\nList&amp;lt;Member&amp;gt; members = team.getMembers(); //(팀 -&amp;gt; 회원)\n    \n  \n\n\n4. 연관관계의 주인\n\n\n  엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다.\n  JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 하는데 이것을 연관관계의 주인이라 한다.\n\n\n1) 양방향 매핑의 규칙 : 연관관계의 주인\n\n\n  양방향 연관관계 매핑 시 연관관계의 주인을 정해야 한다.\n    \n      연관관계의 주인은 데이터베이스 연관관계와 매핑되고 외래키를 관리(등록, 수정, 삭제) 할 수 있다.\n      연관관계의 주인이 아닌 쪽은 읽기만 할 수 있다.\n    \n  \n  연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것이다.\n\n\n2) 연관관계의 주인은 외래 키가 있는 곳\n\n\n  \n    연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다.\n\n    📍 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다. 따라서 @ManyToOne 에는 mappedBy 속성이 없다.\n  \n\n\n5. 양방향 연관관계 저장\n\n  연관관계의 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다.\n    team.getMember().add(member);  //무시(연관관계의 주인 아님)\nmember.setTeam(team);  //연관관계 설정(연관관계의 주인)\n    \n  \n\n\n6. 양방향 연관관계의 주의점\n\n  양방향 연관관계를 설정하고 가장 흔히 하는 실수는 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것이다.\n\n\n1) 순수한 객체까지 고려한 양방향 연관관계\n\n\n  그렇다면 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까?\n객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 안전하다.\n  객체를 고려한 양방향 연관관계\n    Team team1 = new Team(&quot;team1&quot;, &quot;팀1&quot;);\nem.persist(team);\n  \nMember member1 = new Member(&quot;member1&quot;, &quot;회원1&quot;);\n  \n//양방향 연관관계 설정\nmember1.setTeam(team1);\nteam1.getMembers().add(member1);\nem.persist(member1);\n    \n  \n\n\n2) 연관관계 편의 메소드\n\n\n  양방향 연관관계는 결국 양쪽 다 신경을 써야 하는데 연관관계를 설정하는 메소드를 각각 호출하다보면 실수로 둘 중 하나만 호출해서 양방향이 깨질 수 있다.\n  한 번에 양방향 관계를 설정하는 메소드를 연관관계 편의 메소드라고 한다.\n    public void setTeam(Team team) {\n   this.team = team;\n   team.getMembers().add(this);\n}\n    \n  \n\n\n3) 연관관계 편의 메소드 작성 시 주의사항\n\n\n  연관관계를 변경할 때 이전에 설정한 연관관계가 제거되지 않기 때문에 이전의 연관관계를 삭제하는 코드를 추가해야 한다.\n    public void setTeam(Team team) {\n   //기존 팀과 관계를 제거\n   if (this.team != null) {\n   \t\tthis.team.getMembers().remove(this);\n   }\n   this.team = team;\n   team.getMembers().add(this);\n}\n    \n    객체에서 양방향 연관관계를 사용하려면 로직을 견고하게 작성해야 한다.\n  \n\n\n7. 정리\n\n- 단방향\n\n\n  연관관계가 하나인 단방향 매핑은 언제나 연관관계의 주인이다.\n  단방향은 항상 외래 키가 있는 곳을 기준으로 매핑하면 된다.\n\n\n- 양방향\n\n\n  단방향 매핑과 비교해서 양방향 매핑은 복잡하다. 연관관계의 주인도 정해야 하고, 두 개의 단방향 연관관계를 양방향으로 만들기 위해 로직도 잘 관리해야 한다.\n  양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것뿐이다.\n  연관관계 주인의 반대편은 mappedBy로 주인을 지정해야 한다.\n  양방향 매핑 시에는 무한 루프에 빠지지 않게 조심해야 한다.\n    \n      예를 들어, Member.toString()에서 getTeam()을 호출하고, Team.toString()에서 getMember()를 호출하면 무한 루프에 빠질 수 있다.\n      이런 문제는 엔티티를 JSON으로 변환할 때 자주 발생한다. JSON 라이브러리들은 보통 무한루프에 빠지지 않도록 하는 어노테이션이나 기능을 제공한다.\n      Lombok 라이브러리를 사용할 때도 자주 발생한다.\n    \n  \n\n\n\n"
} ,
  
  {
    "title"    : "RESTful",
    "category" : "Programming",
    "tags" : "TIL",
    "url"      : "/programming/2022/02/25/restful/",
    "date"     : "February 25, 2022",
    "excerpt"  : "1) RESTful 이란?\n\nREST는 Representational State Transfer 의 약어로, 클라이언트과 서버가 데이터를 주고 받는 방식에 대한 아키텍처 스타일이다. REST에는 여섯 가지의 기본 원칙이 있고, 이 가이드를 준수한 인터페이스는 RESTful 하다고 표현한다.\n\n\n  REST는 프로토콜이나 표준이 아닌 아키텍처 제약 조건의 집합이다.\n  구체적인 정의로써 REST는 HTTP URI + HTTP Method 라...",
    "content"  : "1) RESTful 이란?\n\nREST는 Representational State Transfer 의 약어로, 클라이언트과 서버가 데이터를 주고 받는 방식에 대한 아키텍처 스타일이다. REST에는 여섯 가지의 기본 원칙이 있고, 이 가이드를 준수한 인터페이스는 RESTful 하다고 표현한다.\n\n\n  REST는 프로토콜이나 표준이 아닌 아키텍처 제약 조건의 집합이다.\n  구체적인 정의로써 REST는 HTTP URI + HTTP Method 라고 할 수 있다.\nURI로 대상 자원을 명시하고 Method로 해당 자원에 대한 행위를 정의한다.\n\n\n2) REST API\n\n\n  REST API는 REST 아키텍처 스타일을 따르는 API를 말한다.\n  API 개발자는 다양한 방법으로 REST를 구현할 수 있다.\n  REST API를 통해 서버로 요청하면 클라이언트에 리소스 상태를 전송한다.\n  헤더와 매개변수는 REST API 요청의 HTTP 메소드에서 중요하다.\n    \n      헤더와 매개변수에는 요청의 메타데이터, 권한 부여, URI(Uniform Resource Identifier), 캐싱, 쿠키 등에 관한 중요한 식별자 정보를 포함하고 있기 때문이다.\n      헤더에는 요청 헤더와 응답 헤더가 있으며, 각 헤더에는 자체 HTTP 연결 정보와 상태 코드가 있다.\n    \n  \n\n\n3) REST 6가지 원칙\n\n\n  인터페이스 일관성(Uniform Interface)\n    \n      URI로 지정된 리소스에 균일하고 통일된 인터페이스를 제공해야 한다.\n      아키텍처를 단순하게 분리하여 특정 언어나 기술에 종속되지 않고 **독립적으로 만들 수 있다.\n      Uniform Interface 조건\n        \n          Identification of resources\n          Manipulation of resources thorough representations\n          Self-descriptive message\n          Hypermedia as the engine of application state (HATEOS)\n          \n        \n      \n    \n  \n\n\n\n  무상태(Stateless)\n    \n      서버는 HTTP 요청에 대한 어떤 것도 저장하지 않는다.\n      클라이언트의 모든 요청에는 해당 요청을 이해할 수 있는 모든 정보가 포함되어야 한다.\n      컨텍스트를 유지해야 하는 세션, 인증과 인가에 대한 정보 또한 클라이언트에만 보관되며, 각 요청 시 해당 정보를 모두 포함하여 서버에 요청한다.\n      \n    \n  \n\n\n\n  캐시 처리 가능(Cacheable)\n    \n      서버는 Cache-Control 헤더에 해당 요청이 캐싱이 가능한 지에 대한 여부를 제공해야 한다.\n      캐싱이 가능하다면 클라이언트는 응답을 캐싱하여 서버와 클라이언트 간의 상호작용을 줄이고, 성능과 서버 가용성을 늘릴 수 있다.\n    \n  \n\n\n\n  계층화(Layered System)\n    \n      REST는 다중 계층 구조를 가질 수 있도록 허용한다. (예를 들어 API 서버와 DB서버 그리고 인증 서버를 따로 둘 수 있다.)\n      각 레이어는 자기와 통신하는 컴포넌트 외 레이어에 대해서는 정보를 얻을 수 없다.\n      클라이언트는 REST 서버와 상호작용할 뿐, REST가 상호작용하는 레이어나 그 외 중간 레이어들, end server에 직접적으로 요청할 수 없으며 이들의 상호작용 또한 볼 수 없다.\n      \n    \n  \n\n\n\n  클라이언트/서버 구조(Client-Server)\n    \n      클라이언트와 서버는 서로 독립적이어야 하며, 클라이언트는 오직 URIs 리소스만 알아야한다.\n      클라이언트와 서버의 인터페이스가 변경되지 않는 한, 이 둘은 독립적으로 개발되거나 대체될 수 있게 유지해야한다.\n      \n    \n  \n\n\n\n  Code on demand\n    \n      서버가 클라이언트에서 실행시킬 수 있는 로직을 전송하여 클라이언트의 기능을 확장시킬 수 있다.\n      이를 통해 클라이언트가 사전에 구현해야하는 기능의 수를 줄여 간소화시킬 수 있다.\n    \n  \n\n\n\n\n\n   Reference\n   REST\n   What is a REST API?\n   RESTful API 이란\n   RESTful API를 위한 6가지 원칙과 네이밍\n   RESTful 에 대한 이해\n   REST를 사용할 때 주의해야할 점\n\n\n"
} ,
  
  {
    "title"    : "Layered Architecture",
    "category" : "Programming",
    "tags" : "TIL",
    "url"      : "/programming/2022/02/19/layered-architecture/",
    "date"     : "February 19, 2022",
    "excerpt"  : "1) Layered Architecture란?\n\n\n  Layered Architecture란 말 그대로 계층이 나뉘어져 있는 아키텍쳐를 뜻한다.\n  Layered Architecture의 주된 목표는 어플리케이션을 여러 개의 굵직한 횡단 관심사(cross-cutting concern)로 분리해, 각각의 Layer는 하나의 관심사에만 집중할 수 있도록 하는 것이다.\n  Layered Architecture의 궁극적인 목표는 Applicati...",
    "content"  : "1) Layered Architecture란?\n\n\n  Layered Architecture란 말 그대로 계층이 나뉘어져 있는 아키텍쳐를 뜻한다.\n  Layered Architecture의 주된 목표는 어플리케이션을 여러 개의 굵직한 횡단 관심사(cross-cutting concern)로 분리해, 각각의 Layer는 하나의 관심사에만 집중할 수 있도록 하는 것이다.\n  Layered Architecture의 궁극적인 목표는 Application Layer와 Domain Layer가 기술에 대해 가지는 의존성을 최소화하여, 오직 순수한 비즈니스 로직을 작성하는 데에 집중할 수 있게 하는 것이다.\n  \n\n\n\n\n2) Layered Architecture의 구성\n\nPresentation Layer\n\n\n  처음 사용자가 서버에 요청을 하게 되면 요청은 Presentation Layer에 전달된다.\n  Presentation Layer는 주로 Controller, View(Template Engine)로 구성되며 사용자와 소프트웨어(웹 서버)간 상호작용의 최선단에 위치한다.\n  \n    Controller는 Presentation Layer의 ‘필수’ 구성요소 중 하나입니다. \nPresentation Layer의 뒤에 위치하는 Application Layer는 요청이 Android App으로부터의 API 호출인지, 웹 페이지의 Form으로부터 온 것인지, Socket 통신에 의해 온 것인지에 상관없이 동일하게 동작할 수 있어야 한다.\n이를 위해 Presentation Layer(Controller)에서는 외부로부터의 요청을 형태가 고정된 DTO(Data Transfer Object)로 변환한다.\n\n    Presentation Layer의 역할\n- Client의 요청을 변환\n- 기본적인 요청 내용 검증\n- 수행결과를 Client에 반환\n  \n\n\nApplication Layer\n\n\n  Application Layer에는 고수준으로 추상화된 어플리케이션 기능이 담겨 있다.\n  Application Layer는 Domain 개념들이 상호작용하는 방식을 기반으로 Domain Layer를 단순하게 만들고, 이를 사용하기 위한 Service 객체를 생성한다.\n  \n    Service 객체란 특정한 행위를 추상화하는 객체이다.\n\n    Application Layer(Service)가 필요한 이유\n    \n      도메인 레이어가 외부(Infra, External Service)에 대해 가지는 의존을 최소화 한다.\n      여러 클라이언트로부터 호출될 수 있는 API를 제공한다.ex) Rendering 후 웹페이지를 반환하는 controller와 REST API controller는 같은 서비스를 호출할 수 있습니다.\n      도메인을 사용하는 여러 방법들을 제시한다.ex) 일반 사용자용 서비스는 더 적은 유형의 데이터만을 반환해야 합니다. Admin용 서비스는 대부분의 권한을 가지는 대신, 더 꼼꼼한 로깅을 요구합니다.\n      저장, 외부로의 데이터 전달, 트랜잭션과 같은 문제 해결의 보조적인 기능(Application Logic)을 도메인 로직으로부터 분리한다. 도메인 로직의 수행으로 인해 발생하는 side effect를 Domain Layer가 최대한 모를 수 있게 합니다.\n    \n\n    이 Layer를 부르는 명칭은 이 Layer를 부르는 맥락마다 달라지기 때문에, 헷갈리는 경우가 많습니다. \n우선 일반적인 Layered Architecture나, DDD에서는 이 계층을 Application Layer라고 부르며, Clean Architecture에서는 Usecase로 부릅니다.\n간혹 Application Layer가 Application Service로 구성되기 때문에, Service Layer로 부르는 경우도 있습니다.(이 때는 Domain Servcie와의 구별이 요구됩니다.)\n  \n\n\nDomain Layer\n\n\n  Domain Layer는 백엔드 서버 아키텍처에 있어서 핵심 로직을 구현하는 부분이다.\n  Domain Layer에는 어떤 외부 관심사에도 의존하지 않고 순수한 비즈니스 로직만을 담아야 한다.\n  Domain Layer를 순수하게 유지하는 것은 유지보수, 확장성을 결정하는 가장 중요한 요인이라고 할 수 있다.\n  \n    도메인 레이어의 유형은 크게 Transaction Script와 Domain Model Pattern을 들 수 있다.\n\n    \n      \n        Transaction Script\n트랜잭션 스크립트(Transaction Script) 패턴은 이렇게 하나의 트랜잭션으로 구성된 로직을 단일 함수 또는 단일 스크립트에서 처리하는 구조를 갖는다. \n그래서 패턴의 이름이 트랜잭션 스크립트이다. 트랜잭션 스크립트는 JSP를 처음 공부하는 사람들이 가장 먼저 몸에 습득하는 패턴으로서 모델 1 구조가 가장 간단한 트랜잭션 스크립트 패턴에 해당한다.\n      \n      \n        Domain Model\n도메인 모델(Domain Model)은 흔히 말하는 객체 지향 분석 설계에 기반해서 구현하고자 하는 도메인(비즈니스 영역)의 모델을 생성하는 패턴이다. \n도메인 모델은 비즈니스 영역에서 사용되는 객체를 판별하고, 객체가 제공해야 할 목록을 추출하며, 각 객체간의 관계를 정립하는 과정을 거친다. \n명사와 동사를 구분해서 명사로부터 객체를 추출해내고, 동사로부터 객체의 기능 및 객체 사이의 관계를 유추해낸다.\n객체를 기반으로 하는 도메인 모델의 주요 특징은 데이터와 프로세스가 혼합되어 있다는 것이며, 객체 간의 복잡한 연관 관계를 갖고 있고, 상속 등을 통해서 객체의 기능과 역할을 확장할 수 있다.\n      \n    \n  \n  도메인 레이어를 구성할 때, 도메인 모델 패턴을 사용한다면 객체를 얼마나 잘 정의하는지, 객체들 사이에 협력이 얼마나 잘 만들어지는지에 따라서 가독성, 생산성이 좌우된다.\n\n\nInfrastructure Layer\n\n\n  Infra Layer는 다른 애플리케이션이나, 데이터베이스 등 외부 요소와 연결을 수행한다.\n  \n    DB 서버 연결(Spring Data), Message Queue 연결(kafka, rabbitMQ), 외부 API 요청 방식 정의(RestTemplate, Feign) 등\n\n    Infra Layer의 기능\n- DB로의 요청/응답 처리\n- Rest API 연결 방식 구현\n- 메시지 전송\n  \n\n\n\n\n\n  Reference\n  The DDD Layered Architecture\n  Gradle과 함께하는 Backend Layered Architecture\n  Spring 코드와 함께 보는 백엔드 서버 아키텍처\n  도메인 로직 패턴 1 - 트랜잭션 스크립트, 도메인 모델\n  계층형 아키텍처\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (4) 엔티티 매핑",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/02/17/jpa-4/",
    "date"     : "February 17, 2022",
    "excerpt"  : "✓︎ @Entity\n✓︎ @Table\n✓︎ 데이터베이스 스키마 자동 생성\n✓︎ DDL 생성 기능\n✓︎ 기본 키 매핑\n✓︎ 필드와 컬럼 매핑: 레퍼런스\n\n1. @Entity\n\n\n  JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션을 붙여야 한다.\n  주의사항\n    \n      기본 생성자는 필수로 있어야 한다.\n      final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.\n      ...",
    "content"  : "✓︎ @Entity\n✓︎ @Table\n✓︎ 데이터베이스 스키마 자동 생성\n✓︎ DDL 생성 기능\n✓︎ 기본 키 매핑\n✓︎ 필드와 컬럼 매핑: 레퍼런스\n\n1. @Entity\n\n\n  JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 어노테이션을 붙여야 한다.\n  주의사항\n    \n      기본 생성자는 필수로 있어야 한다.\n      final 클래스, enum, interface, inner 클래스에는 사용할 수 없다.\n      저장할 필드에 final을 사용하면 안 된다.\n    \n  \n\n\n2. @Table\n\n\n  @Table 은 엔티티와 매핑할 테이블을 지정한다. 생략하면, 매핑한 엔티티 이름을 테이블 이름으로 사용한다.\n\n\n3. 다양한 매핑 사용\n\n  예제 코드\n- 회원 엔티티에 다양한 매핑 적용\n  컬럼 매핑에 대한 설명은 아래에서 추가 설명 필드와 컬럼 매핑: 레퍼런스\n\n\n4. 데이터베이스 스키마 자동 생성\n\n\n  JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.\n  \n    persistence.xml 에 속성을 추가하여 create, create-drop, update, validate, none 으로 스키마 생성을 설정할 수 있다.\n\n    &amp;lt;property name=&quot;hibernate.show_sql.auto&quot; value=&quot;create&quot;&amp;gt;\n    \n  \n\n\n운영 서버에서는 create, create-drop, update 처럼 DLL 을 수정하는 옵션은 절대 사용하면 안된다. 이 옵션들은 운영중인 데이터베이스의 테이블이나 컬럼을 삭제할 수 있다.\n\n5. DDL 생성 기능\n\n\n  DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고, JPA의 실행 로직에는 영향을 주지 않는다.\n  DDL 생성 기능 사용 예시\n    \n      @Column의 nullable 속성으로 not null 제약조건을 추가할 수 있다.\n      \n        @Column의 length 속성으로 문자의 크기를 지정할 수 있다.\n\n          @Column(name = &quot;NAME&quot;, nullable = false, length = 10)\n  private String userName;\n        \n      \n      \n        @Table의 @UniqueConstraint 속성으로 유니크 제약조건을 추가할 수 있다.\n\n          @Table(name = &quot;MEMBER&quot;, uniqueConstraints = {@UniqueConstraint(\n          name = &quot;NAME_AGE_UNIQUE&quot;,\n          columnNames = {&quot;NAME&quot;, &quot;AGE&quot;})})\n        \n      \n    \n  \n  이런 기능을 사용하면 애플리케이션 개발자가 엔티티만 보고도 손쉽게 다양한 제약 조건을 파악할 수 있는 장점이 있다.\n\n\n6. 기본 키 매핑\n\n\n  기본키를 애플리케이션에서 직접 할당하는 대신에 데이터베이스가 생성해주는 값을 사용할 수도 있다.\n  JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.\n    \n      직접 할당 : 기본 키 생성을 데이터베이스에 위임한다.\n      자동 생성\n      IDENTITY : 기본 키 생성을 데이터베이스에 위임한다.\n      SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.\n      TABLE : 키 생성 테이블을 사용한다.\n    \n  \n  자동 생성 전략이 다양한 이유는 데이터베이스 벤더마다 지원하는 방식이 다르기 때문이다.\n  \n    키 생성 전략을 사용하려면 persistence.xml에 설정을 추가해야 한다.\n\n      &amp;lt;property name=&quot;hibernate.id.new_generator_mappings&quot; value=&quot;true&quot;&amp;gt;\n    \n  \n\n\n1) 기본키 직접 할당 전략\n\n\n  기본 키를 직접 할당하려면 @Id 로 매핑하면 된다.\n  em.persist() 로 엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당하는 방법이다.\n  \n\n\n2) IDENTITY 전략\n\n\n  IDENTITY는 기본 키 생성을 데이터베이스에 위임하는 전략이다.\n  \n    @GeneratedValue 어노테이션의 strategy 속성을 GenerationType.IDENTITY 로 설정한다.\n\n      @Entity\n  public class Board {\n      @Id\n      @GeneratedValue(strategy = GenerationType.IDENTITY)\n      private Long id;\n  }\n    \n  \n  IDENTITY 전략은 데이터베이스에 값을 저장하고 나서야 기본 키 값을 구할 수 있을 때 사용한다.\n    \n      IDENTITY 전략은 데이터를 데이터베이스에 INSERT 한 후에 기본 키 값을 조회할 수 있다.\n      JDBC3에 추가된 Statement.getGeneratedKeys()를 사용하면 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어 올 수 있다. 하이버네이트는 이 메소드를 사용해서 데이터베이스와 한 번만 통신한다.\n    \n  \n  엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다.\n    \n      따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.\n    \n  \n  \n\n\n3) SEQUENCE 전략\n\n\n  SEQUENCE 전략은 시퀀스를 사용해서 기본 키를 생성한다.\n  @SequenceGenerator를 사용해서 시퀀스 생성기를 등록한다.\n  시퀀스 생성기를 실제 데이터베이스의 시퀀스와 매핑한다.\n  \n    @GeneratedValue 어노테이션의 strategy 속성을 GenerationType.SEQUENCE 로 설정한다.\n\n      @Entity\n  @SequenceGenerator(\n      name = &quot;BOARD_SEQ_GENERATOR&quot;,\n      sequenceName = &quot;BOARD_SEQ&quot;,\n      initialValue = 1, allocationSize = 1)\n  public class Board {\n      @Id\n      @GeneratedValue(strategy = GenerationType.SEQUENCE,\n                                      generator = &quot;BOARD_SEQ_GENERATOR&quot;)\n      private Long id;\n  }\n    \n  \n  SEQUENCE 전략은 em.persist()를 호출할 때 먼저 데이터베이스의 시퀀스를 사용해서 식별자를 조회한다.\n  \n    @SequenceGenerator 속성\n\n    \n\n    \n      SequenceGenerator.allocationSize 의 기본 값이 50인 것에 주의해야 한다. 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다.\n      \n    \n  \n\n\n4) TABLE 전략\n\n\n  TABLE 전략은 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략이다.\n  @TableGenerator를 사용해서 테이블 키 생성기를 등록한다.\n  테이블 생성기를 실제 데이터베이스의 테이블과 매핑한다.\n  \n    @GeneratedValue 어노테이션의 strategy 속성을 GenerationType.TABLE 로 설정한다.\n\n    @Entity\n@TableGenerator(\n    name = &quot;BOARD_SEQ_GENERATOR&quot;,\n    table = &quot;MY_SEQUENCE&quot;,\n    pkColumnValue = &quot;BOARD_SEQ&quot;, allocationSize = 1)\npublic class Board {\n    @Id\n    @GeneratedValue(strategy = GenerationType.TABLE,\n                                    generator = &quot;BOARD_SEQ_GENERATOR&quot;)\n    private Long id;\n}\n    \n  \n  TABLE 생성 전략은 시퀀스 대신에 테이블을 사용한다는 것만 제외하면 SEQUENCE 전략과 내부 동작 방식이 같다.\n  \n    @TableGenerator 속성\n\n    \n  \n  TABLE 전략은 값을 조회하면서 SELECT 쿼리를 사용하고 다음 값으로 증가시키기 위해 UPDATE 쿼리를 사용한다. 이 전략은 SEQUENCE 전략과 비교해서 데이터베이스와 한 번 더 통신하는 단점이 있다. TABLE 전략을 최적화하려면 @TableGenerator.allocationSize를 사용하면 된다.\n  \n\n\n5) AUTO 전략\n\n\n  AUTO 전략은 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택한다.\n    \n      예를 들어, 오라클을 선택하면 SEQUENCE, MySQL을 선택하면 IDENTITY 전략을 자동으로 선택한다.\n    \n  \n  @GeneratedValue 어노테이션의 strategy 속성을 GenerationType.AUTO 로 설정한다.\n  키 생성 전략이 아직 확정되지 않은 개발 초기 단계나 프로토타입 개발 시 편리하게 사용할 수 있다.\n  AUTO를 사용할 때 SEQUENCE 나 TABLE 전략이 선택되면 키 생성용 테이블을 미리 만들어 두어야 한다. 만약 스키마 자동 생성 기능을 사용한다면 하이버네이트가 기본값을 사용해서 적절한 시퀀스나 키 생성용 테이블을 만들어 줄 것이다.\n\n\nJPA는 모든 엔티티에 일관된 방식으로 대리 키 사용을 권장한다.\n\n7. 필드와 컬럼 매핑: 레퍼런스\n\n\n\n@Column\n\n\n  @Column은 객체 필드를 테이블 컬럼에 매핑한다.\n  name, nullable 이 주로 사용된다.\n  \n    nullable 의 기본값이 true 이므로, 자바 기본 타입 사용시 @Column을 사용할 경우 nullable = false로 지정해 주어야 한다. 또는, @Column을 생략하면 자바 기본 타입일 경우 자동으로 not null 로 생성된다.\n\n      int data1; //@Column 생략, 자바 기본타입\n  /* 생성된 DDL : data1 integer not null */\n    \n  Integer data2; //@Column 생략, 객체 타입\n  /* 생성된 DDL : data2 integer */\n    \n  @Column\n  int data3; //@Column 사용, 자바 기본타입\n  /* 생성된 DDL : data3 integer */\n    \n\n    \n\n    @Colum(\n    nullable = false, \n    unique = true,\n    columnDefinition = &quot;varchar(100) default &#39;EMPTY&#39;&quot;,\n    length = 100\n)\nprivate String registrationNumber;\n    \n  \n\n\n@Enumerated\n\n\n  자바의 enum 타입을 매핑할 대 사용한다.\n  EnumType.ORDINAL은 enum 에 정의된 순서대로 ADMIN 은 0, USER 는 1 값이 데이터베이스에 저장된다.\n    \n      장점 : 저장되는 데이터 크기가 작아진다.\n      단점 : 이미 저장이 되었다면 enum 의 순서를 변경하면 안된다.\n    \n  \n  EnumType.STRING 은 enum 이름 그래도 ADMIN은 ‘ADMIN’, USER는 ‘USER’라는 문자로 데이터베이스에 저장된다. (권장)\n    \n      장점 : 저장된 enum 의 순서가 바뀌거나 enum이 추가되어도 안전하다.\n      단점 : 저장되는 데이터 크기가 크다.\n    \n  \n\n\n@Temporal\n\n\n  날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용한다. 하지만 날짜 및 시간을 다룰 때 이 타입들이 잘 사용되지 않는다.\n  \n    Java 8은 java.time 패키지 를 도입했으며 JDBC 4.2 API는 추가 SQL 유형 TIMESTAMP WITH TIME ZONE 및 TIME WITH TIME ZONE을 지원한다. 또한, OffsetTime 및 OffsetDateTime 클래스를 통해 UTC에 대한 오프셋 로컬 시간대를 지원한다.\n\n      @Column(name = &quot;local_time&quot;, columnDefinition = &quot;TIME&quot;)\n  private LocalTime localTime;\n    \n  @Column(name = &quot;local_date&quot;, columnDefinition = &quot;DATE&quot;)\n  private LocalDate localDate;\n    \n  @Column(name = &quot;local_date_time&quot;, columnDefinition = &quot;TIMESTAMP&quot;)\n  private LocalDateTime localDateTime;\n    \n  @Column(name = &quot;offset_time&quot;, columnDefinition = &quot;TIME WITH TIME ZONE&quot;)\n  private OffsetTime offsetTime;\n    \n  @Column(name = &quot;offset_date_time&quot;, columnDefinition = &quot;TIMESTAMP WITH TIME ZONE&quot;)\n  private OffsetDateTime offsetDateTime;\n    \n\n    \n  \n  \n\n\n@Lob\n\n\n  데이터베이스 BLOL, CLOB 타입과 매핑한다.\n\n\n@Transient\n\n\n  이 필드는 매핑하지 않고, 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.\n\n\n@Access\n\n\n  AccessType.FIELD\n    \n      필드 접근 권한이 private 이어도 필드에 직접 접근할 수 있다.\n    \n  \n  AccessType.PROPERTY\n    \n      접근자(getter)를 사용한다.\n    \n  \n  @Access를 설정하지 않으면 @Id 의 위치를 기준으로 접근 방식이 설정된다.\n  \n    @Id가 필드에 있으므로 @Access(AccessType.FIELD)로 설정한 것과 같다. 따라서 @Access 는 생략 가능하다.\n\n      @Entity\n  @Access(AccessType.FIELD)\n  public class Member {\n      @Id\n      private String id;\n  }\n    \n  \n  \n    @Id가 프로퍼티에에 있으므로 @Access(AccessType.PROPERTY)로 설정한 것과 같다. 따라서 @Access 는 생략 가능하다.\n\n      @Entity\n  @Access(AccessType.PROPERTY)\n  public class Member {\n    \n      private String id;\n    \n      private String data1;\n    \n      @Id\n      public String getId() {\n          return id;\n      }\n    \n      @Column\n      public String getData1() {\n          return data1;\n      }\n  }\n    \n  \n  필드 접근 방식과 프로퍼티 접근 방식을 함께 사용할 수도 있다.\n    \n      \n        회원 엔티티를 저장하면 회원 테이블 FULLNAME 컬럼에 firstName + lastName 결과과 저장된다.\n\n        @Entity\npublic class Member {\n    @Id\n    private String id;\n    \n    @Transient\n    private String firstName;\n    \n    @Transient\n    private String lastName;\n    \n    @Access(AccessType.PROPERTY)\n    public String getFullName() {\n        return firstName + lastName;\n    }\n}\n        \n      \n    \n  \n\n\n\n\n\n   Reference\n   JJPA 엔티티 매핑 공부의 기록\n   JPA 공부 - 4\n\n"
} ,
  
  {
    "title"    : "토비의 스프링 - 1장. 오브젝트와 의존관계(3)",
    "category" : "Book",
    "tags" : "Spring",
    "url"      : "/book/2022/02/15/toby-1-6/",
    "date"     : "February 15, 2022",
    "excerpt"  : "1.4 제어의 역전(IoC)\n1.5 스프링의 IoC\n1.6 싱글톤 레지스트리와 오브젝트 스코프\n\n1.4 제어의 역전(IoC)\n\n  이전 장\n에서 UserDao가 ConnectionMaker 인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트(=UserDaoTest)에게 그 책임을 넘기도록 수정했다.\n  하지만, UserDaoTest에서도 테스트 이외의 역할을 수행하므로, 성격이 다른 책임이나 관심사를...",
    "content"  : "1.4 제어의 역전(IoC)\n1.5 스프링의 IoC\n1.6 싱글톤 레지스트리와 오브젝트 스코프\n\n1.4 제어의 역전(IoC)\n\n  이전 장\n에서 UserDao가 ConnectionMaker 인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트(=UserDaoTest)에게 그 책임을 넘기도록 수정했다.\n  하지만, UserDaoTest에서도 테스트 이외의 역할을 수행하므로, 성격이 다른 책임이나 관심사를 분리해야 한다.\n  이번 장에서는 분리시킬 기능의 오브젝트를 생성하고, 생성된 오브젝트가 연결되도록 관계를 맺어주는 방법에 대해 알아보자.\n\n\n오브젝트 팩토리\n\n  분리시킬 기능을 담당하는 클래스를 만든다. 이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데, 이런 일을 하는 오브젝트를 흔히 팩토리(factory)라고 부른다.\n  \n    예제 코드\n- UserDao의 생성 책임을 맡은 팩토리 클래스\n\n    기존의 UserDaoTest 에서는 UserDao를 생성하기 위해 connectionMaker 구현체를 넘겨주어야 했다. \n  new UserDao(connectionMaker)\n변경된 UserDaoTest 에서는 UserDaoFactory에서 UserDao의 생성을 담당한다.\n  new UserDaoFactory().userDao()\n  \n  설계도로서의 팩토리 클래스\n    \n      UserDaoFactory 클래스는 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있는 설계도와 같은 역할을 한다.\n    \n\n    \n\n    \n      UserDaoFactory를 분리했을 때 얻을 수 있는 장점은 매우 다양하지만, 그중에서 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.\n      \n    \n  \n\n\n오브젝트 팩토리의 활용\n\n  여러 개의 DAO를 생성해야 하는 경우에도 중복 되는 코드를 별도의 메소드로 분리한뒤 생성하면 된다.\n  예제 코드\n- 여러 개의 DAO를 생성하기 위한 DaoFactory\n    \n      \n    \n  \n\n\n제어권의 이전을 통한 제어관계 역전\n\n  \n    제어의 역전이란, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.\n\n    초기에 개발한 UserDao를 보면 테스트용 main() 메소드에서 UserDao를 직접 생성하고 사용한다. UserDao 또한 자신이 사용할 ConnectionMaker의 구현 클래스를 자신이 결정하여, 언제 어떻게 만들지를 스스로 관장한다.\n  \n  \n  제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 자신이 어떻게 만들어지고 어디서 사용되는지를 알 수 없다.\n    \n      서블릿이나 JSP, EJB처럼 컨테이너 안에서 동작하는 구조는 간단한 방식이긴 하지만 제어의 역전 개념이 적용되어 있다고 볼 수 있다.\n      \n        제어의 역전 개념이 적용된 예를 디자인패턴에서도 여럿 찾아볼 수 있다.\n\n        템플릿 메소드는 제어권을 상위 템플릿 메소드에게 넘기고 자신은 필요할 때 호출되어 사용되록 한다는, 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이라고 볼 수 있다.\n      \n      \n      프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. (라이브러리 VS. 프레임워크)\n      \n    \n  \n  \n    제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.\n\n    원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었다. 그런데 지금은 DaoFactory에게 있다. DaoFactory는 오브젝트 수준의 가장 단순한 IoC 컨테이너(혹은 IoC 프레임워크)라고 불릴 수 있다.\n  \n\n\n1.5 스프링의 IoC\n\n  스프링은 IoC를 모든 기능의 기초가 되는 기반 기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크다.\n  스프링의 핵심을 담당하는 것은 빈 팩토리(=애플리케이션 컨텍스트)이다.\n\n\n오브젝트 팩토리를 이용한 스프링 IoC\n\n  빈(Bean) : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트 제어의 역전이 적용된 오브젝트\n  빈 팩토리 : 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트\n  애플리케이션 컨텍스트 : 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄하는 빈 팩토리\n\n\n✔︎ 빈 팩토리와 애플리케이션 컨텍스트라는 용어는 동일하다고 생각하면 된다.\n빈 팩토리라고 말할 때는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고, 애플리케이션 컨텍스트라고 말할 때는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 좀 더 부각된다고 보면 된다.\n\n\n  DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트\n    \n      \n        예제 코드\n- 스프링 빈 팩토리가 사용할 설정정보를 담은 DaoFactory 클래스\n\n        @Configuration\npublic class DaoFactory {\n@Bean\npublic UserDao userDao() {\nUserDao dao = new UserDao(connectionMaker());\nreturn dao;\n}\n    \n    @Bean\n    public ConnectionMaker connectionMaker() {\n        ConnectionMaker connectionMaker = new DConnectionMaker();\n        return connectionMaker;\n    }\n}\n        \n\n        애노테이션 방식 설정정보 (자바 코드의 탈을 쓰고 있지만, 사실은 XML과 같은 스프링 전용 설정정보라고 보는 것이 좋다.)\n      \n      @Configuration : 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식\n      @Bean : 오브젝트 생성을 담당하는 IoC용 메소드라는 표시\n      \n    \n  \n\n\n애플리케이션 컨텍스트의 동작방식\n\n  애플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 빈 팩토리인 셈이다.\n\n\n\n\n\n  \n  애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점\n    \n      클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.\n      \n        오브젝트의 생성과 관계설정 뿐만 아니라 종합 IoC 서비스를 제공한다.\n\n        오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.\n      \n      \n      애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.\n    \n  \n  \n\n\n1.6 싱글톤 레지스트리와 오브젝트 스코프\n스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.\n\n동일성과 동등성\n- 동일성(identity) : 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.  \n- 동등성(equality) : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. equals() 메소드 비교의 값이 같다.\n\n\n  \n\n\n싱글톤 레지스트리로서의 애플리케이션 컨텍스트\n애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.\n스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.\n\n스프링이 처음 설계됐던 대규모 엔터프라이즈 서버환경에서는 초당 수십에서 수백 번씩 요청을 받아서 처리할 수 있는 높은 성능이 요구되는 환경이었다.\n요청이 올 때마다 매번 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다면, 요청 한번에 n개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 (500 * n)개의 새로운 오브젝트가 생성된다.\n이런 문제를 해결하기 위해, 서블릿은 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.\n\n\n  애플리케이션 안에서 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다.\n  하지만, 디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다.\n    \n      private 생성자를 갖고 있기 대문에 상속할 수 없다.\n      싱글톤은 테스트 하기 힘들다.\n      서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.\n      싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.\n      \n    \n  \n  스프링 레지스트리 : 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.\n  싱글톤 레지스트리의 장점은 static 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라, 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다.\n  \n\n\n싱글톤과 오브젝트의 상태\n\n  싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근해서 사용할 수 있다. 상태관리에 주의해야 한.\n  기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.\n\n\n다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다. 저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다.\n\n\n  따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지 방식으로 만들지 않는다.\n  스프링의 싱글톤 빈으로 사용되는 클래스를 만들 때는 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다.\n  다만, 읽기전용의 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 공유해도 문제가 되지 않는다.\n  \n\n\n스프링 빈의 스코프\n\n  스프링 빈의 기본 스코프는 싱글톤이다.\n  \n    스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.\n\n    \n      \n        \n          Scope\n          Description\n        \n      \n      \n        \n          singleton\n          (기본값) 스프링 IoC 컨테이너당 하나의 인스턴스만 사용\n        \n        \n          prototype\n          매번 새로운 빈을 정의해서 사용\n        \n        \n          request\n          HTTP 라이프사이클 마다 하나의 빈을 사용\n        \n        \n          session\n          HTTP 세션마다 하나의 빈을 사용\n        \n        \n          application\n          ServeltContext 라이프사이클 동안 하나의 빈만 사용\n        \n        \n          websocket\n          websocket 라이프사이클 안에서 하나의 빈만 사용\n        \n      \n    \n  \n\n\n\n   Reference\n   [Spring] 제어의 역전(IoC)\n   스프링 컨테이너와 스프링 빈\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (3) 영속성 관리",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/02/14/jpa-3/",
    "date"     : "February 14, 2022",
    "excerpt"  : "✓︎ 엔티티 매니저 팩토리와 엔티티 매니저\n✓︎ 영속성 컨텍스트란?\n✓︎ 엔티티의 생명주기\n✓︎ 영속성 컨텍스트의 특징\n✓︎ 플러시\n✓︎ 준영속\n\n1. 엔티티 매니저 팩토리와 엔티티 매니저\n\n\n  엔티티 매니저 팩토리는 엔티티를 만드는 공장인데, 공장을 만드는 비용이 상당히 크기 때문에, 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다. 반면에, 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않는다.\n...",
    "content"  : "✓︎ 엔티티 매니저 팩토리와 엔티티 매니저\n✓︎ 영속성 컨텍스트란?\n✓︎ 엔티티의 생명주기\n✓︎ 영속성 컨텍스트의 특징\n✓︎ 플러시\n✓︎ 준영속\n\n1. 엔티티 매니저 팩토리와 엔티티 매니저\n\n\n  엔티티 매니저 팩토리는 엔티티를 만드는 공장인데, 공장을 만드는 비용이 상당히 크기 때문에, 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계되어 있다. 반면에, 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않는다.\n  엔티티 매니저는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든 일을 처리한다.\n엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스로 생각하면 된다.\n  엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에는 절대 공유하면 안된다.\n\n\n\n\n\n  엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. 보통 트랜잭션을 시작할 대 커넥션을 획득한다.\n\n\n\n\n\n  \n    EntityManagerFactory / EntityManager 생성하기\n\n    EntityManagerFactory emf = Persistence.createEntityManagerFactory(&quot;jpabook&quot;);\nEntityManager em = emf.createEntityManager();\n    \n\n    Persistence.createEntityManagerFactory(&quot;jpabook&quot;)를 호출하면META-INF/persistence.xml 에 있는 정보를 바탕으로 EntityManagerFactory를 생성한다.\n  \n\n\n2. 영속성 컨텍스트란?\n\n\n  엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.\n  영속성 컨텍스트는 논리적인 개념으로, 엔티티 매니저를 생성할 때 만들어져서 엔티티 매니저를 통해 접근하고 관리할 수 있다.\n  \n    엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장하기\n\n    em.persist(member);\n    \n  \n\n\n3. 엔티티의 생명주기\n\n\n  엔티티에는 4가지 상태가 존재한다.\n\n\n\n\n\n\n  \n    비영속\n\n    //객체를 생성한 상태(비영속)\nMember member = new Member();\nmember.setId(&quot;member1&quot;);\nmember.setName(&quot;sayho&quot;);\n    \n  \n  \n    영속\n\n    //객체를 저장한 상태(영속)\nem.persist(member);\n  \n//JPQL을 사용해서 조회힌 상태(영속)\nem.find(Member.class, id);\n    \n  \n  \n    준영속\n\n    //회원 엔티티를 영속성 컨텍스트에서 분리(준영속)\nem.detach(member);\n  \n//영속성 컨텍스트를 닫거나 초기화(준영속)\nem.close();\nem.clear();\n    \n  \n  \n    삭제\n\n    //객체를 삭제한 상태(삭제)\nem.remove(member);\n    \n  \n\n\n4. 영속성 컨텍스트의 특징\n\n\n  영속 상태는 식별자 값이 반드시 있어야 한다. 식별자 값이 없으면 예외가 발생한다.\n  JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한는데, 이것을 플러시(flush)라고 한다.\n\n\n영속성 컨텍스트가 엔티티를 관리할 때의 장점\n\n\n  1차 캐시\n    \n      영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라고 한다.\n      엔티티를 조회할 때 1차 캐시에서 먼저 찾고, 엔티티가 1차 캐시에 없으면 데이터베이스에서 조회한다.\n      \n        1차 캐시는 key: @Id로 매핑한 식별자, value: Entity 인스턴스인 Map 형태이다.\n데이터베이스를 바로 조회하지 않고, 메모리에 있는 1차 캐시를 사용하여 성능상 이점이 생긴다.\n      \n      \n        엔티티 등록: persist(), commit()\n\n        EntityManager em = emf.createEntityManager();\nEntityTransaction transaction = em.getTransaction();\n    \n// 엔티티 매니저는 데이터 쓰기 시 트랜잭션을 시작해야 한다.\ntransaction.begin();\n    \nem.persist(memberA);\nem.persist(memberB);\n// 여기까지 INSERT SQL을 DB에 보내지 않는다.\n    \ntransaction.commit(); // 커밋하는 순간 DB에 INSERT SQL을 보낸다.\n        \n      \n      persist()\n\n      \n        commit()\n\n      \n      \n      \n    \n  \n  영속 엔티티의 동일성 보장\n    \n      \n        식별자가 같은 엔티티를 조회할 때 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다.\n\n        Member a = em.find(Member.class, &quot;member1&quot;);\nMember b = em.find(Member.class, &quot;member1&quot;);\n    \nSystem.out.println(a == b); //동일성 비교(true)\n        \n      \n    \n\n    \n      동일성과 동등성\n- 동일성(identity) : 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.\n- 동등성(equality) : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. 자바에서 동등성 비교는 equals() 메소드를 구현해야 한다.\n    \n\n    \n      \n    \n  \n  트랜잭션을 지원하는 쓰기 지연\n    \n      엔티티 매니저는 트랜잭션을 커밋하기 직전까지 쓰기 지연 SQL 저장소에 모아둔다.\n      트랜잭션을 커밋하면 엔티티 매니저는 영속성 컨텍스트를 flush() 한다.\n플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업이다.\n(쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다.)\n      이 기능을 잘 활용하면 쓰기 모아둔 쿼리를 데이터베이스에 한번에 전달해서 성능을 최적화 할 수 있다.\n      \n    \n  \n  변경 감지\n    \n      \n        JPA로 엔티티를 수정할 때는 단순히 엔티티를 조회해서 데이터만 변경하면 된다.\n\n          Member memberA = em.find(Member.class, &quot;memberA&quot;);\n  memberA.setAge(10);\n  // em.update(memberA); // 이런 코드가 없어도 된다.\n  transaction.commit();\n        \n      \n      \n        엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 변경 감지라고 한다.\n      \n    \n\n    \n\n    \n      JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 스냅샷을 저장한다. 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.\n      변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.\n      JPA는 변경된 필드만 업데이트 하는 것이 아니라, 엔티티의 모든 필드를 업데이트 한다.\n      모든 필드를 데이터베이스에 보내면 데이터 전송량이 증가하는 단점이 있지만, 수정 쿼리가 동일하여 쿼리를 재사용할 수 있다.\n      엔티티에 필드가 많거나 저장되는 내용이 너무 크면 수정할 필드만 동적으로 UPDATE SQL을 생성하는 전략을 선택할 수 있다.\n@DynamicUpdate : 상황에 따라 다르지만 컬럼이 대략 30개 이상이면 정적 수정 쿼리보다 동적 수정 쿼리가 빠르다고 한다.\n      \n    \n  \n  지연 로딩\n    \n      실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다.\n    \n  \n\n\n5. 플러시\n\n\n  플러시(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화한다.\n  데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 트랜잭션이라는 작업 단위가 있기 때문이다.\n\n\n영속성 컨텍스트를 플러시하는 방법\n1) em.flush() 를 직접 호출한다.\n      테스트나 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고 거의 사용하지 않는다.\n  2) 트랜잭션 커밋 시 플로시가 자동 호출된다.\n  3) JPQL 쿼리 실행 시 플러시가 자동 호출된다.\n\n플러시 모드 옵션\n\n  FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시 (기본값)\n  FlushModeType.COMMIT : 커밋할 때만 플러시\n  COMMIT 모드는 성능 최적화를 위해 사용할 수 있다.\n\n\n6. 준영속\n\n\n  영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태라고 한다.\n  준영속 상태에의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.\n\n\n준영속 상태로 만드는 방법\n1) em.detach(entity) : 특정 엔티티만 준영속 상태로 전환한다.\n  2) em.clear() : 영속성 컨텍스트를 완전히 초기화한다.\n  3) em.close() : 영속성 컨텍스트를 종료한다.\n\n\n  엔티티를 준영속 상태로 전환 : detach()\n    \n      1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다.\n    \n  \n  영속성 컨텍스트 초기화 : clear()\n    \n      영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만든다.\n    \n  \n  영속성 컨텍스트 종료 : close()\n    \n      해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다.\n    \n  \n\n\n준영속 상태의 특징\n\n  거의 비영속 상태에 가깝다.\n  식별자 값을 가지고 있다.\n  지연 로딩을 할 수 없다.\n\n\n병합 : merge()\n\n  준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다.\n  병합은 비영속 엔티티도 영속 상태로 만들 수 있다.\n  병합은 파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트를 조회하고 찾는 엔티티가 없으면 데이터베이스에서 조회한다. 만약 데이터베이스에서도 발견하지 못하면 새로운 엔티티를 생성해서 병합한다.\n\n\n\n   Reference\n   3.3 엔티티의 생명주기\n   3.4 영속성 컨텍스트의 특징\n   JPA란 무엇인가?\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (2) JPA 시작",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/02/07/jpa-2/",
    "date"     : "February 7, 2022",
    "excerpt"  : "✓︎ 라이브러리와 프로젝트 구조\n✓︎ 객체 매핑 시작\n✓︎ persistence.xml 설정\n✓︎ 애플리케이션 개발\n\n1. 이클립스 설치와 프로젝트 불러오기\n\n『자바 ORM 표준 JPA 프로그래밍』 예제 프로젝트\n\n2. H2 데이터베이스 설치\n\nH2 Database 홈페이지에서 다운로드 H2 설치 참고\n\n3. 라이브러리와 프로젝트 구조\n\n\n  JPA 구현체로 하이버네이트를 사용하기 위한 핵심 라이브러리\n    \n      hibernate...",
    "content"  : "✓︎ 라이브러리와 프로젝트 구조\n✓︎ 객체 매핑 시작\n✓︎ persistence.xml 설정\n✓︎ 애플리케이션 개발\n\n1. 이클립스 설치와 프로젝트 불러오기\n\n『자바 ORM 표준 JPA 프로그래밍』 예제 프로젝트\n\n2. H2 데이터베이스 설치\n\nH2 Database 홈페이지에서 다운로드 H2 설치 참고\n\n3. 라이브러리와 프로젝트 구조\n\n\n  JPA 구현체로 하이버네이트를 사용하기 위한 핵심 라이브러리\n    \n      hibernate-core : 하이버네이트 라이브러리\n      hibernate-entitymanager : 하이버네이트가 JPA 구현체로 동작하도록 JPA 표준을 구현한 라이브러리\n      hibernate-jpa-2.1-api : JPA 2.1 표준 API를 모아둔 라이브러리\n    \n  \n\n\n4. 객체 매핑 시작\n\n\n  \n    @Entity\n이 클래스를 테이블과 매핑한다고 JPA에게 알려준다. @Entity가 사용된 클래스를 엔티티 클래스라고 한다.\n  \n  \n    @Table\n엔티티 클래스에 매핑할 테이블 정보를 알려준다. @Table을 생략하면 클래스 이름을 테이블 이름으로 매핑한다. name 속성을 사용하여 원하는 테이블 명을 지정할 수 있다.\n  \n  \n    @Id\n엔티티 클래스의 필드를 테이블의 기본키(Primary Key)에 매핑한다. @Id가 사용된 필드를 식별자 필드라고 한다.\n  \n  \n    @Column\n필드를 컬럼에 매핑한다. name 속성을 사용하여 원하는 컬럼명을 지정할 수 있다.\n  \n  \n    매핑 정보가 없는 필드\n매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명으로 매핑한다.\n\n    JPA 어노테이션의 패키지는 javax.persistence 이다.\n  \n\n\n5. persistence.xml 설정\n\n\n  \n    JPA는 persistence.xml을 사용해서 필요한 설정 정보를 관리한다. 이 설정파일이 META-INF/persistence.xml 클래스 패스 경로에 있으면 별도의 설정 없이 JPA가 인식할 수 있다.\n  \n  \n    &amp;lt;persistence-unit name=&quot;jpabook&quot;&amp;gt;\nJPA 설정은 영속성 유닛이라는 것부터 시작하는데 일반적으로 연결할 데이터베이스당 하나의 영속성 유닛을 등록한다. 영속성 유닛에는 고유한 이름을 부여해야 한다.\n  \n  JPA 표준 속성\n    \n      javax.persistence.jdbc.driver : JDBC 드라이버\n      javax.persistence.jdbc.user : 데이터베이스 접속 아이디\n      javax.persistence.jdbc.passowrd : 데이터베이스 접속 비밀번호\n      javax.persistence.jdbc.url : 데이터베이스 접속 URL\n      \n    \n  \n  하이버네이트 속성\n    \n      hibernate.dialect : 데이터베이스 방언(Dialect)설정\n      hibernate.show_sql : 하이버네이트가 실행한 SQL을 출력한다.\n      hibernate.formt_sql : 하이버네이트가 실행한 SQL을 출력할 때 보기 쉽게 정렬한다.\n      hibernate.use_sql_comments : 쿼리를 출력할 때 주석도 함께 출력한다.\n      hibernate_id.new_generator_mappings : JPA 표준에 맞춘 새로운 키 생성 전략을 사용한다.\n    \n  \n  \n    JPA 표준 속성은 특정 구현체에 종속되지 않는다. 반면에 하이버네이트 전용 속성은 하이버네이트에서만 사용할 수 있다.\n  \n  \n    SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 방언(Dialect)이라고 한다.\n\n    \n  \n\n\n6. 애플리케이션 개발\n\n▪️ 엔티티 매니저 설정\n\n\n\n\n  \n    엔티티 매니저 팩토리\n엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야 한다.\n  \n  \n    엔티티 매니저  \nJPA의 기능 대부분은 엔티티 매너저가 제공한다.\n엔티티 매니저는 내부에 데이터소스(데이터베이스 커넥션)를 유지하면서 데이터베이스와 통신한다.\n엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용하면 안된다.\n  \n\n\n▪️ 트랜잭션 관리\n\n\n  JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다.\n\n\n▪️ JPQL\n\n\n  JPA는 SQL을 추상화한 JPAL이라는 객체지향 쿼리 언어를 제공한다.\n  JPQL은 엔티티 객체를 대상으로 쿼리한다. 쉽게 이야기해서 클래스와 필드를 대상으로 쿼리한다.\n  JPQL은 데이터베이스 테이블을 전혀 알지 못하고 엔티티 객체를 참조한다.\n\n\n//목록 조회\nTypedQuery&amp;lt;Member&amp;gt; query = em.createQurery(&quot;select m from Member m&quot;, Member.class);\nList&amp;lt;Member&amp;gt; members = query.getResultLiost\n\n\n\n   Reference\n   자바 ORM 표준 JPA\n\n"
} ,
  
  {
    "title"    : "토비의 스프링 - 1장. 오브젝트와 의존관계(2)",
    "category" : "Book",
    "tags" : "Spring",
    "url"      : "/book/2022/02/05/toby-1-3/",
    "date"     : "February 5, 2022",
    "excerpt"  : "1.3 DAO의 확장\n1.3.1 클래스의 분리\n1.3.2 인터페이스의 도입\n1.3.3 관계 설정 책임의 분리\n1.3.4 원칙과 패턴\n\n1.3 DAO의 확장\n\n  지금까지 데이터 액세스 로직을 어떻게 만들 것인가와 DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다.\n  변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.\n\n\n클래스의 분리\n\n\n\n\n  SimpleConnectionMak...",
    "content"  : "1.3 DAO의 확장\n1.3.1 클래스의 분리\n1.3.2 인터페이스의 도입\n1.3.3 관계 설정 책임의 분리\n1.3.4 원칙과 패턴\n\n1.3 DAO의 확장\n\n  지금까지 데이터 액세스 로직을 어떻게 만들 것인가와 DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다.\n  변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.\n\n\n클래스의 분리\n\n\n\n\n  SimpleConnectionMaker라는 새로운 클래스를 만들고 DB 생성 기능을 그 안에 넣는다.\n  예제 코드\n    \n      독립된 SimpleConnectionMaker를 사용하게 만든 UserDao\n      독립시킨 DB 연결 기능인 SimpleConnectionMaker\n      \n    \n  \n  클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.\n    \n      SimpleConnectionMaker의 메소드가 달라지면 일일이 수정해야 한다는 점\n    \n    \n      DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다는 점\n    \n    이런 문제의 근본적인 원인은 UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다.\n    \n      \n    \n  \n\n\n인터페이스의 도입\n\n  가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다.\n  추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이다.\n  자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스다.\n\n\n\n\n\n  이제 UserDao는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.\n  예제 코드\n    \n      ConnectionMaker 인터페이스\n      ConnectionMaker 구현 클래스\n      ConnectionMaker 인터페이스를 사용하도록 개선한 UserDao\n      \n    \n  \n\n\n관계 설정 책임의 분리\n\n\n  \n    인터페이스를 이용한 분리에도 불구하고 여전히 UserDao 변경 없이 DB 커넥션 기능의 확장이 자유롭지 못하다.\n\n      public UserDao() {\n      connectionMaker = new DConnectionMaker();\n  }\n    \n    \n      어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지에 대한 관심사가 UserDao 생성자에 포함되어 있다.\n      이 관심사를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.\n      ConnectionMaker 인터페이스를 사용한 덕분에 UserDao와 ConnectionMaker의 구현 클래스들은 직접 연결되어 있지 않은 것처럼 보인다.\n      하지만 UserDao 에서 new DConnectionMacker() 를 해주는 코드가 있음으로써 클래스 사이에 직접적인 관계가 있다.\n      UserDao가 NConnectionMaker를 사용하게 하려면 UserDao의 코드를 변경해야 한다.\n    \n\n    \n\n    \n      클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다.\n      오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.\n    \n    \n      \n    \n  \n  이 문제를 해결하려면 객체지향의 다형성이라는 특징을 이용하면 된다.\n    \n      특정 클래스를 알지 못하더라도 해당 클래스가 인터페이스를 구현했다면, 그 클래스의 인터페이스 타입을 사용할 수 있다.\n      \n        UserDao가 DConnectionMacker를 사용하게 하려면 두 클래스 사이에 런타임 사용관계(=링크 =의존관계)를 맺어주면 된다.\n\n        \n      \n      ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성하는 책임을 UserDao의 생성자가 아니라 UserDao의 클라이언트에게 넘기도록 수정한다.\n      \n    \n  \n  예제 코드\n    \n      UserDao - 수정한 생성자\n      \n        관계설정 책임이 추가된 UserDao 클라이언트인 main() 메소드\n      \n      이제 UserDao는 자신의 관심사이자 책임인 사용자 데이터 액세스 작업을 수행하는데만 집중할 수 있다.\n      더 이상 DB 생성 방법이나 전략에 대해서는 고민할 필요가 없다.\n      \n    \n\n    \n\n    인터페이스를 도입하고 클라이언트의 도움을 받는 방법은 상속을 사용하는 것에 비해서 훨씬 더 유연하다.\n\n    \n      \n    \n  \n\n\n객체지향 설계와 프로그래밍 이론을 통해서 지금까지 적용한 벙법을 정리해보자 객체 지향 설계 원칙(SOLID)\n\n원칙과 패턴\n\n개방 폐쇄 원칙\n\n개방 폐쇄 원칙(OCP, Open-Closed Principle)은 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙이다.\nUserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려 있다. 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 변화에 영향을 받지 않으므로 변경에는 닫혀 있다.\n\n  \n\n\n객체지향 설계 원칙(SOLID)\n\n  \n\n\n높은 응집도 낮은 결합도\n\n\n  응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.\n  높은 응집도는 클래스 레벨뿐 아니라 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.\n  응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다.\n\n\n처음에 개발한 초난감 DAO처럼 여러 관심사와 책임이 얽혀있는 복잡한 코드에서는 변경이 필요한 부분을 찾아내는 것도 번거로울뿐더러 변경으로 인한 오류를 발생시키지 않는지도 일일이 확인해야 한다.\n반면, ConnectionMaker 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우, DB 커넥션 풀을 활용하는 ConnectionMaker 구현 클래스를 새로 만들기만 하면 된다.\n\n\n  낮은 결합도는 높은 응집도보다 더 민감한 원칙이다.\n  결합도란 하나의 오브젝트에 변경이 일어날 때, 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도이다.\n\n\nConnectionMaker 인터페이스의 도입으로 인해 DB 연결 기능을 구현한 클래스가 바뀌더라도 DAO의 코드는 변경될 필요가 없다.\nConnectionMaker의 클래스를 결정하는 책임을 DAO의 클라이언트로 분리한 덕분에 ConnectionMaker의 구현 클래스가 바뀌어도, DAO의 코드를 수정할 필요가 없다.\n\n  \n\n\n전략 패턴\n\n  개선한 UserDtoTest, UserDao, ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다.\n  전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 자주 사용되는 패턴이다.\n  전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘(=전략)을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 클래스를 바꿔서 사용할 수 있게 하는 디자인 패턴이다.\n\n\nUserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스(=전략)를 바꿔가면서 사용할 수 있게 분리했다.\n\n\n   Reference\n   [토비 스프링] 사용자 DAO\n   [토비의 스프링 vol.1]1장 오브젝트와 의존관계\n\n"
} ,
  
  {
    "title"    : "라이브러리 VS. 프레임워크",
    "category" : "Programming",
    "tags" : "TIL",
    "url"      : "/programming/2022/02/04/library-framework/",
    "date"     : "February 4, 2022",
    "excerpt"  : "1) Library 정의\n\n  다른 프로그램들과 링크되기 위하여 존재하는 비휘발성 자원의 모임이다.\n응용프로그램 개발을 위해 필요한 기능을 모아 놓은 소프트웨어\n    \n      구성 데이터, 문서, 서브루틴(함수), 클래스, 값 등을 포함할 수 있다.\n      보통 링크 될 수 있도록 컴파일된 형태인 목적코드(object code) 형태로 존재한다.\n    \n  \n  다른 프로그램과 링크되는 방식에 따라 정적 라이브러리와 동적 라이브...",
    "content"  : "1) Library 정의\n\n  다른 프로그램들과 링크되기 위하여 존재하는 비휘발성 자원의 모임이다.\n응용프로그램 개발을 위해 필요한 기능을 모아 놓은 소프트웨어\n    \n      구성 데이터, 문서, 서브루틴(함수), 클래스, 값 등을 포함할 수 있다.\n      보통 링크 될 수 있도록 컴파일된 형태인 목적코드(object code) 형태로 존재한다.\n    \n  \n  다른 프로그램과 링크되는 방식에 따라 정적 라이브러리와 동적 라이브러리(공유 라이브러리)로 구분한다.\n\n\n2) Library 특징\n\n  유저의 코드가 라이브러리를 호출해서 사용하는 구조로 동작한다.\n실행 흐름에 대한 제어를 유저 코드가 담당\n  기능들을 어떻게 사용할지 사용자가 결정한다.\n  라이브러리를 사용하면 코드의 재사용, 부품화, 기술의 유출을 방지, 개발 시간을 단축 등의 장점이 있다.\n\n\n3) Framework 정의\n\n  소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게 일련의 협업화된 형태로 클래스들을 제공하는 것\n-랄프 존슨(Ralph Johnson)\n\n\n\n  프레임워크는 소프트웨어 개발을 위해 구조적인 틀과 구현 코드를 함께 제공한다.\n프레임워크 = 디자인 패턴 + 라이브러리\n    \n      프레임워크는 애플리케이션의 구조와 디자인(디자인 패턴)을 결정한다.\n      디자인 패턴이 적용되어 구현된 기반코드(라이브러리)를 제공한다.\n    \n  \n\n\n4) Framework  특징\n\n  디자인 패턴은 프레임워크의 핵심적인 특징이고, 프레임워크를 사용하는 애플리케이션에 그 패턴이 적용된다.\n  프레임워크 쪽에서 사용자의 코드를 호출하는 구조로 동작한다.\n실행 흐름에 대한 제어를 프레임워크가 담당\n➡︎  제어의 역전 개념이 적용된 대표적인 기법\n  많은 프레임워크는 템플릿 메소드 패턴 기반으로 만들어진 클래스를 서브 클래싱해서 사용하도록 되어있다.\n이미 설계되어있는 흐름구조에 따라 동작하게 된다.\n\n\n5) Framework와  Library 비교\n\n\n라이브러리와 프레임워크의 차이는 응용프로그램의 흐름 주도권을 누가 가지고 있는가이다.\n\n\n\nFramework 활용의 지름길\n- 프레임워크의 라이브러리를 살펴볼 때, 적용된 디자인 패턴을 주목해서 살펴보자.\n- 레퍼런스 매뉴얼과 API/클래스 문서를 꾸준히 보고, 유용한 라이브러리 기능에 대한 지식을 쌓자.\n\n\n  Reference\n  프레임워크의 재발견\n  정적 라이브러리(Static Library) &amp;amp; 공유 라이브러리(Shared Library)\n  API vs 라이브러리 vs 프레임워크\n\n\n"
} ,
  
  {
    "title"    : "토비의 스프링 - 1장. 오브젝트와 의존관계(1)",
    "category" : "Book",
    "tags" : "Spring",
    "url"      : "/book/2022/02/04/toby-1-2/",
    "date"     : "February 4, 2022",
    "excerpt"  : "들어가며\n1.1 초난감 DAO\n1.2 DAO의 분리\n\n들어가며\n\n스프링이란 무엇인가?\n\n  애플리케이션의 기본 틀 - 스프링 컨테이너\n    \n      스프링 컨테이너(=애플리케이션 컨텍스트) : 스프링에서 제공하는 런타임 엔진\n      스프링 컨테이너는 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트(=Bean)를 생성하고 관리한다.\n      \n    \n  \n  공통 프로그래밍 모델 - IoC/DI, 서비스 추상화, AOP\n ...",
    "content"  : "들어가며\n1.1 초난감 DAO\n1.2 DAO의 분리\n\n들어가며\n\n스프링이란 무엇인가?\n\n  애플리케이션의 기본 틀 - 스프링 컨테이너\n    \n      스프링 컨테이너(=애플리케이션 컨텍스트) : 스프링에서 제공하는 런타임 엔진\n      스프링 컨테이너는 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트(=Bean)를 생성하고 관리한다.\n      \n    \n  \n  공통 프로그래밍 모델 - IoC/DI, 서비스 추상화, AOP\n 스프링 프레임워크의 3가지 프로그레밍 모델 (라이브러리 VS. 프레임워크)\n    \n      IoC/DI\n        \n          오브젝트의 생명주기와 의존관계에 대한 프로그레밍 모델이다.\n          스프링은 객체지향 설계 원칙과 디자인 패턴의 핵심 원리를 담고 있는 IoC/DI를 프레임워크의 근간으로 삼고 있다.\n        \n      \n      서비스 추상화\n        \n          구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 두는 방법이다.\n        \n      \n      AOP\n        \n          애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델이다.\n          \n        \n      \n    \n  \n  기술 API\n    \n      스프링은 개발의 다양한 영역에 바로 활용할 수 있는 방대한 양의 기술 API를 제공한다.\n    \n  \n\n\n1.1 초난감 DAO\n\n  JDBC를 이용하는 작업의 일반적인 순서\n    \n      DB 연결을 위한 Connection을 가져온다.\n      SQL 을 담은 Statement(또는 PreparedStatement)를 만든다.\n      만들어진 Statement를 실행한다.\n      조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.\n      작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.\n    \n  \n  예제 코드\n    \n      사용자 정보 저장용 자바빈 User 클래스\n      JDBC를 이용한 등록과 조회 기능이 있는 UserDao\n      테스트용 main() 메소드\n    \n  \n\n\n1.2 DAO의 분리\n관심사의 분리\n\n  객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.\n\n\n  그러면 어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있었을까? 그것은 분리와 확장을 고려한 설계가 있었기 때문이다.\n\n\n  관심사의 분리란, 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것이다.\n\n\n  \n  중복 코드 메소드 추출\n    \n      예제 코드 \n- getConnection() 메소드를 추출해서 중복을 제거한 UserDao\n      \n    \n  \n  변경사항에 대한 검증: 리팩토링과 테스트\n    \n      main() 메소드를 이용해 테스트를 실행한다.\n      두번째 테스트 부터는 테이블의 기본키인 id 값이 중복되기 때문에 예외가 발생한다.\n      main() 메소드 테스트를 다시 실행하기 전에 User 테이블의 사용자 정보를 삭제해줘야 한다.\n    \n\n    리팩토링\n리팩토링인 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.\n  \n  \n  상속을 통한 확장\n    \n      예제 코드\n- 상속을 통한 확장 방법이 제공되는 UserDao\n\n      \n    \n\n    - 템플릿 메소드 패턴\n  슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법의 디자인 패턴\n  \n  - 팩토리 메소드 패턴\n  서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 디자인 패턴\n\n    \n\n    디자인 패턴\n  디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다.\n  디자인 패턴을 사용하면 설계의 의도와 해결책을 파악하기 쉽다는 장점이 있다.\n\n    \n      상속의 한계\n        \n          만약 UserDao가 다른 목적을 위해 상속을 사용하고 있다면, 자바에서 다중상속을 허용하지 않기 때문에 상속을 사용할 수 없다.\n        \n        \n          상속을 통한 부모-자식 클래스의 관계는 생각보다 밀접하다. 그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나, 서브클래스의 변경이 슈퍼클래스에 영향을 주지 않도록 제한해야 한다.\n        \n        \n          만약 다른 DAO 클래스를 만들어야 하는 경우, getConnection() 구현 코드가 중복된다.\n        \n      \n    \n  \n\n\n\n   Reference\n   [토비 스프링] 사용자 DAO\n   [토비의 스프링 vol.1]1장 오브젝트와 의존관계\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (1) JPA 소개",
    "category" : "Book",
    "tags" : "JPA",
    "url"      : "/book/2022/02/03/jpa-1/",
    "date"     : "February 3, 2022",
    "excerpt"  : "✓︎ SQL을 직접 다룰때 발생하는 문제점\n✓︎ 패러다임의 불일치\n✓︎ JPA란 무엇일까?\n\n\n  “왜 실무에서 테이블 설계는 다들 열심히 하면서 제대로 된 객체 모델링은 하지 않을까?”\n\n\n\n  “왜 객체 지향의 장점을 포기하고 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하도록 개발할까?”\n\n\n1. SQL을 직접 다룰때 발생하는 문제점\n\n\n  진정한 의미의 계층 분할이 어렵다.\n  엔티티를 신뢰할 수 없다.\n  SQL에 의존적인 ...",
    "content"  : "✓︎ SQL을 직접 다룰때 발생하는 문제점\n✓︎ 패러다임의 불일치\n✓︎ JPA란 무엇일까?\n\n\n  “왜 실무에서 테이블 설계는 다들 열심히 하면서 제대로 된 객체 모델링은 하지 않을까?”\n\n\n\n  “왜 객체 지향의 장점을 포기하고 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하도록 개발할까?”\n\n\n1. SQL을 직접 다룰때 발생하는 문제점\n\n\n  진정한 의미의 계층 분할이 어렵다.\n  엔티티를 신뢰할 수 없다.\n  SQL에 의존적인 개발을 피하기 어렵다.\n\n\n2. 패러다임의 불일치\n\n\n  관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다.\n  따라서 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.\n  문제는 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제를 해결하는데 너무 많은 시간과 코드를 소비하는데 있다.\n  \n    결국, 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다.\n\n    연관관계\n\n    \n      객체는 참조를 사용해서 다른 객체와 연과관계를 가지고 참조에 접근해서 연관된 객체를 조회한다. 반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.\n      객체를 테이블에 맞추어 모델링하면 객체를 테이블에 저장하거나 조회할 때는 편리하다.\n      하지만 객체는 연관된 객체의 참조를 통해 연관된 객체를 찾을 수 있다.\n      객체 모델은 외래키가 필요 없고, 참조만 있으면 된다.\n      반면에 테이블은 참조가 필요 없고 외래키만 있으면 된다.\n      JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다.\n    \n\n    객체 그래프 탐색\n\n    \n      객체에서 참조를 사용해서 연관된 팀을 찾는 것을 객체 그래프 탐색이라고 한다.\nmember.getOrder().getOrderItem()...\n      SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.\n      결국 조회하는 메소드를 상황에 따라 여러 벌 만들어서 사용해야 한다.\n      JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다. 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩이라 한다.\n    \n\n    비교\n\n    \n      \n        데이터베이서는 기본 키의 값으로 각 로우를 구분한다. 반면에 객체는 동일성(identity) 비교와 동등성(equality) 비교라는 두 가지 비교 방법이 있다.\n따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.\n\n        String memberUd = &quot;100&quot;;\nMember member1 = memberDAO.getMember(memberId);\nMember member2 = memberDAO.getMember(memberId);\n    \nmember1 == member2 //다르다\n        \n      \n      위의 코드에서 기본 키 값이 같은 회원 객체를 두 번 조회했다. 그런데 둘을 동일성(==) 비교 하면 false가 반환된다. 왜냐하면 member1과 member2는 같은 데이터베이스 로우에서 조회했지만, 객체 측면에서 볼 때 둘은 서로 다른 인스턴스이기 때문이다.\n      JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.\n    \n  \n\n\n3. JPA란 무엇일까?\n\n\n  \n    JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준이다.\n\n    \n  \n  ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.\n  ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.\n  \n    자바 진영에도 다양한 ORM 프레임워크들이 있는데 그중에 하이버네이트 프레임워크가 가장 많이 사용된다. 하이버네이트는 거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크이다.\n\n    \n  \n  JPA는 자바 ORM 기술에 대한 QPI 표준 명세다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다.\n  왜 JPA를 사용해야 하는가?\n    \n      유지보수\n      패러다임 불일치 해결\n      성능\n      데이터 접근 추상화와 벤터 독립성\n      표준\n    \n  \n\n\n\n   Reference\n   JPA 공부 시작!\n\n"
} ,
  
  {
    "title"    : "Macbook 에서 Java 설치하기",
    "category" : "Daily",
    "tags" : "Mac",
    "url"      : "/daily/2022/02/02/macbook-java/",
    "date"     : "February 2, 2022",
    "excerpt"  : "Java 설치 경로 및 버전 확인\n\n  기존에 설치된 Java 검색\n    brew search jdk\nbrew tap adoptopenjdk/openjdk\n    \n  \n  AdoptOpenJDK 설치\n    brew install --cask adoptopenjdk8\nbrew install --cask adoptopenjdk11\n    \n  \n  \n    Rosetta 2를 설치해야 하는 경우\nRosetta 2는 Intel 프로세서가 ...",
    "content"  : "Java 설치 경로 및 버전 확인\n\n  기존에 설치된 Java 검색\n    brew search jdk\nbrew tap adoptopenjdk/openjdk\n    \n  \n  AdoptOpenJDK 설치\n    brew install --cask adoptopenjdk8\nbrew install --cask adoptopenjdk11\n    \n  \n  \n    Rosetta 2를 설치해야 하는 경우\nRosetta 2는 Intel 프로세서가 장착된 Mac용으로 제작된 앱을 Apple Silicon이 장착된 Mac에서 사용할 수 있게 해주는 에뮬레이터이다. 아래와 같은 메시지가 나오면 ‘설치’를 클릭한 다음 사용자 이름과 암호를 입력하여 설치를 진행한다.\n\n  \n  설치된 Java 검색\n    /usr/libexec/java_home -V\njava --version\n    \n  \n  \n\n\nJava 버전 바꾸기\n자바 버전을 바꾸는 방법중에는 jEnv를 활용하는 방법과 환경변수를 지정하는 방법이 있다.\n여기서는 환경 변수를 변경하는 방법으로 작성되었다.\n\n\n  \n    환경 설정 값과 경로들을 저장하는 파일을 찾는다.\nbash쉘을 사용하는 경우는 ~/.bash_profile이고 zsh쉘을 사용하는 경우 ~/.zshrc 파일을 수정한다.\n\n      echo $SHELL    # 어떤 쉘을 사용하는지 확인\n  vi ~/.zshrc\n    \n\n      # Java Paths\n  export JAVA_HOME_11=$(/usr/libexec/java_home -v11.0.11)\n  export JAVA_HOME_8=$(/usr/libexec/java_home -v1.8.0_292)\n    \n  # Java 11\n  export JAVA_HOME=$JAVA_HOME_11\n    \n  # Java 8\n  # export JAVA_HOME=$JAVA_HOME_8\n    \n  \n\n\n\n  Reference\n  Mac에 Rosetta를 설치해야 하는 경우\n  homebrew로 openjdk 설치하기\n  맥에서 Brew로 자바 설치하기(feat. 자바버전 바꾸기)\n  java_home and JAVA_HOME on macOS\n\n"
} ,
  
  {
    "title"    : "MacBook Setting",
    "category" : "Daily",
    "tags" : "Mac",
    "url"      : "/daily/2022/02/01/macbook/",
    "date"     : "February 1, 2022",
    "excerpt"  : "\n  homebrew 란 macOS 용 패키지 관리 애플리케이션입니다. homebrew는 주로 커맨드라인 도구나 시스템 패키지들을 설치하는 데 사용합니다. \n기본적으로 맥OS용 패키지 관리자이지만, 리눅스나 윈도우의 WSL도 지원하고 있습니다. homebrew는 편리하게 사용할 수 있다는 장점이 있습니다만, 커뮤니티 기반으로 운영되기 때문에 패키지의 안정성이 보장되지 않는다는 단점이 있습니다. \n일부 리눅스 배포판의 경우 패키지 버전 정책...",
    "content"  : "\n  homebrew 란 macOS 용 패키지 관리 애플리케이션입니다. homebrew는 주로 커맨드라인 도구나 시스템 패키지들을 설치하는 데 사용합니다. \n기본적으로 맥OS용 패키지 관리자이지만, 리눅스나 윈도우의 WSL도 지원하고 있습니다. homebrew는 편리하게 사용할 수 있다는 장점이 있습니다만, 커뮤니티 기반으로 운영되기 때문에 패키지의 안정성이 보장되지 않는다는 단점이 있습니다. \n일부 리눅스 배포판의 경우 패키지 버전 정책이 매우 보수적이지만, homebrew로 패키지를 설치하는 경우 거의 항상 최신 버전이 설치됩니다. 구버전의 패키지를 설치하는 것도 가능하지만 번거로운 편입니다.\n\n\n\n  cask 확장을 통해 웹 사이트에서 다운받을 수 있는 애플리케이션을 설치할 수 있습니다.\n\n\n  mas 확장을 통해 앱 스토어에서 다운받을 수 애플리케이션 설치할 수 있습니다.\n\n\n1. 맥북 프로그램 설치\n\n1) homebrew 설치\n\n  \n    Homebrew 홈페이지에서 설치 명령어를 복사하여 터미널에서 실행\n\n     /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;\n    \n    password 입력 후, Enter 로 확인\n  \n  \n    설치가 완료되면 환경 변수 추가 메시지 로그를 확인\n\n    ==&amp;gt; Next steps:\n- Add Homebrew to your PATH in /Users/&amp;lt;USER_ID&amp;gt;/.zprofile:\n  echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &amp;gt;&amp;gt; /Users/&amp;lt;USER_ID&amp;gt;/.zprofile\n  eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;\n- Run `brew help` to get started\n- Further documentation:\n  https://docs.brew.sh\n    \n  \n  \n    환경 변수 추가\n\n    echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &amp;gt;&amp;gt; [path]/.zprofile\neval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;\n    \n  \n\n\n2) brew cask 설치\nbrew install cask \n\n\n3) brew mas 설치\nbrew install mas \n\n\n2. homebrew 기본 명령어\n\n1) brew 명령어\nbrew list\nbrew search [패키지명]\nbrew info [패키지명]\nbrew install [패키지명]\nbrew uninstall [패키지명]\n\n\n2) cask 명령어\nbrew list --cask\nbrew search --cask [앱이름]\nbrew info --cask [앱이름]\nbrew install --cask [앱이름]\nbrew uninstall --cask [앱이름]\n\n\n3) mas 명령어\nmas list\nmas search [앱이름]\nmas info [앱번호]\nbrew install mas [앱번호]\nbrew uninstall mas [앱번호]\n\n\n참고\n\n설치할 목록\n\n    \n      brew\n        \n          java\n          git\n          gradle\n          jq : 커맨드라인 JSON 프로세서\n          tree : tree 명령어\n          newman\n        \n      \n      cask\n        \n          chrome\n          slack\n          docker\n          source tree\n          intellij-idea\n          vscode\n          iterm2\n          Spectacle : 화면 분할\n          Karabiner-Elements : 한/영키\n          Alfred : 검색\n          kap : 화면 기록\n          Postman\n        \n      \n      mas\n        \n          OneDrive\n          Excel\n          Word\n          Power point\n          Todo\n          kakaotalk\n          Joli of Caffeine : 절전 모드 시간 설정\n        \n      \n    \n  \n\n\n\nBundle 로 설치\n\n    \n      \n        brew file 생성 및 실행\n\n        cd ~\n  \n# 생성\nbrew bundle dump\n  \n# 덮어 씌우기\nbrew bundle -f dump\n  \n# 파일 확인\ncat BrewFile\n  \n# 실행\nbrew bundle\n        \n      \n    \n\n  \n\n\n\nhomebrew 초기화 (재설치) \n&amp;nbsp; &amp;nbsp; Error: Cannot install in Homebrew on ARM processor in Intel default prefix\n\n    \n      \n        brew install 시 아래와 같은 에러가 발생하여 homebrew 재설치\n\n        Error: Cannot install in Homebrew on ARM processor in Intel default prefix\nSome of Homebrew&#39;s bottles (binary packages) can only be used with the default\nprefix (/usr/local).\nYou will encounter build failures with some formulae.\nPlease create pull requests instead of asking for help on Homebrew&#39;s GitHub,\nTwitter or any other official channels. You are responsible for resolving\nany issues you experience while you are running this\nunsupported configuration.\n        \n      \n    \n\n    1) /usr/local 폴더에서 Homebrew 폴더 삭제\n\n      rm -rf Homebrew/\n    \n\n    2) Uninstall Homebrew\n\n      /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall.sh)&quot;\n    \n\n    3) Install Homebrew\n\n      /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/\n    \n\n    4) .zshrc에 PATH 추가\n\n      vi ~/.zshrc\n  export $PATH=/usr/local/bin:$PATH\n    \n\n  \n\n\n\n  Reference\n  내가 설치한 맥용 어플리케이션들\n  애플 실리콘 M1 용 Homebrew 설치\n  맥북 추천 무료 앱 8가지 + 크롬 브라우저 익스텐션 1가지\n  Mac - brew(개발 환경 자동화)\n\n"
} ,
  
  {
    "title"    : "프로그래머 성장 과정 대한 정리",
    "category" : "Programming",
    "tags" : "Study",
    "url"      : "/programming/2022/01/31/growing-up/",
    "date"     : "January 31, 2022",
    "excerpt"  : "어느날, Java를 프로그래밍 주 언어로 사용하지만 Java에 대한 지식이 부족하다는 생각이 들었습니다.\n개발에 필요한 지식만 익히지 말고 이번에는 제대로 기본기를 잡아보자! 하는 결심이 들어서 본격적으로 Java 공부를 다시 시작하게 되었습니다. \nJava 기본기 공부를 하기 위해 『Java의 정석』 책과 인프런의 『만들어 가면서 배우는 JAVA 플레이그라운드』 강의를 먼저 학습하기로 했습니다. \n막상 강의를 들으려는데, 초반 내용은 개...",
    "content"  : "어느날, Java를 프로그래밍 주 언어로 사용하지만 Java에 대한 지식이 부족하다는 생각이 들었습니다.\n개발에 필요한 지식만 익히지 말고 이번에는 제대로 기본기를 잡아보자! 하는 결심이 들어서 본격적으로 Java 공부를 다시 시작하게 되었습니다. \nJava 기본기 공부를 하기 위해 『Java의 정석』 책과 인프런의 『만들어 가면서 배우는 JAVA 플레이그라운드』 강의를 먼저 학습하기로 했습니다. \n막상 강의를 들으려는데, 초반 내용은 개발환경을 세팅하는 부분이라 ‘그냥 넘어갈까?’하는 마음이 들었습니다. \n그런데 프로그래밍 학습에 대한 어려움과 극복 방법, 연습에 대한 정리 내용이 있어서 듣다가 정말 중요하고 좋은 내용을 전해주셔서 글로 정리하게 되었습니다.\n\n프로그래밍 학습이 어려운 이유\n\n\n\n  개발을 하기 시작한 초반에는 숙련도가 낮아도 자심감이 어느정도 있지만, 숙련도가 높아짐에도 어느 시점에서 자신감이 많이 떨어지는 시기가 생긴다.\n  개발을 하기 시작한 초반에는 학습할 내용도 많고, 학습 자원도 매우 많지만 초급에서 중급 단계로 넘어가면서 학습할 자원들 찾기 어렵다고 느낀다.\n  숙련도가 높아지기 위해 학습해야 할 주제의 범위가 점점 많아진다.\n\n\n극복하는 방법\n\n\n\n  Hand-Holding Honeymoon\n    \n      다양한 초보 강의를 검토한 후 하나를 선택해서 학습\n      반복해서 연습하기\n    \n  \n  Cliff of Confusion\n    \n      같이 학습할 동료를 구하기\n      다른 사람의 코드 읽기\n      지속적으로 작은 코드를 시작하고 빌드하면서 디버깅에 대한 두려움을 제거하기 → 성취감 Up, 자신감 Up\n    \n  \n  Desert of Despair\n    \n      하나의 목표를 설정한 후 목표에 집중\n      수박 겉핦기 식의 다양한 지식 습득이 아니라 한 분야에 대한 깊이 있는 지식 습득\n      구체적인 목표 의식을 가지고 의식적인 연습을 함으로써 시간 낭비를 최소화\n    \n  \n  Upswing of Awesome\n    \n      Best practices를 찾아 연습하고, 지식의 빈틈을 보완\n      설계, 아키텍처, 배포와 같이 좋은 개발자가 되기 위한 연습\n      이 단계를 극복하기 위한 핵심은 피드백을 받는 것 → 코칭을 해줄 멘토나 동료를 찾는 것이 중요!\n    \n  \n\n\n프로그래밍 학습에서 취업까지 현실적인 조언\n\n  주변 정리 및 우선순위 조정이 필요하다. 방해받지 않고 프로그래밍에 집중할 수 있어야 한다.\n  프로그래머로 취업하기 위한 학습 기간이 필요하다(최소 1년). 그렇지 않으면 회사 일과 학습을 병행하는 것이 매우 힘들다.\n  개발이 처음이라면 온라인 교육 컨텐츠 보다는 단기 속성 학원을 추천한다. 하지만 학원에서 배운다고 프로그래밍적 사고를 제대로 갖추기는 어렵다. 무엇을 어떻게 학습할 것인지에 대한 감을 잡는 것이 필요하다.\n  같이 학습할 사람을 만드는 것이 가장 중요하다. 매일 일정한 시간, 장소로 출퇴근 하면서 꾸준하게 공부한다.\n  학습하면서 다음 단계로 무엇을 해야할지 모를 때, 포기하고 싶을 때에는 주변 강사님, 선배 개발자에게 조언을 구할 필요가 있다. 또, 가끔씩 회사에 지원해보면서 현재 나의 상태와 부족한 점을 파악하면서 재조정\n해본다.\n\n\n프로그래밍 학습 방식\n\n  기초 지식부터 쌓은 후 무엇인가를 만들어 가는 방식\n  무엇인가를 만들어 가면서 관련된 지식을 학습해 가는 방식\n\n\n- 자신이 어떤 방식으로 학습할 때 더 효과적으로 학습하는 성향인지 찾아야 한다.\n- 어떤 방식으로 학습할 때 스트레스를 덜 받고 즐거움을 느끼는지 찾아야 한다.\n\n프로그래밍 연습\n\n  무엇인가 한 가지를 끝낸 후, 바로 다음 단계로 넘어가기 보다는 어색하거나, 이해되지 않거나, 궁금한 내용을 정리하는 시간을 갖자\n  반복해서 연습하자\n  과정 속에서 배운 부분이 있으면 그날 그날 내용을 정리하는 습관을 갖자\n  호기심을 가지고 다양한 시도를 해보자\n\n\n\n   Reference\n   자바의 정석 강의\n   만들어 가면서 배우는 JAVA 플레이그라운드\n   Why Learning to Code is So Damn Hard\n\n\n"
} 
  
]
