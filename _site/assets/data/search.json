[
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (2) JPA 시작",
    "category" : "Book",
    "url"      : "/book/2022/02/07/jpa-2/",
    "date"     : "February 7, 2022",
    "excerpt"  : "1. 이클립스 설치와 프로젝트 불러오기\n2. H2 데이터 베이스 설치\n3. 라이브러리와 프로젝트 구조\n4. 객체 매핑 시작\n5. persistence.xml 설정\n6. 애플리케이션 개발\n\n1. 이클립스 설치와 프로젝트 불러오기\n\n『자바 ORM 표준 JPA 프로그래밍』 예제 프로젝트\n\n2. H2 데이터베이스 설치\n\n\n  H2 Database 홈페이지에서 다운로드\nH2 설치 참고\n\n\n3. 라이브러리와 프로젝트 구조\n\n\n  JPA 구현체로 하이...",
    "content"  : "1. 이클립스 설치와 프로젝트 불러오기\n2. H2 데이터 베이스 설치\n3. 라이브러리와 프로젝트 구조\n4. 객체 매핑 시작\n5. persistence.xml 설정\n6. 애플리케이션 개발\n\n1. 이클립스 설치와 프로젝트 불러오기\n\n『자바 ORM 표준 JPA 프로그래밍』 예제 프로젝트\n\n2. H2 데이터베이스 설치\n\n\n  H2 Database 홈페이지에서 다운로드\nH2 설치 참고\n\n\n3. 라이브러리와 프로젝트 구조\n\n\n  JPA 구현체로 하이버네이트를 사용하기 위한 핵심 라이브러리\n    \n      hibernate-core : 하이버네이트 라이브러리\n      hibernate-entitymanager : 하이버네이트가 JPA 구현체로 동작하도록 JPA 표준을 구현한 라이브러리\n      hibernate-jpa-2.1-api : JPA 2.1 표준 API를 모아둔 라이브러리\n    \n  \n\n\n4. 객체 매핑 시작\n\n\n  \n    @Entity\n이 클래스를 테이블과 매핑한다고 JPA에게 알려준다. @Entity가 사용된 클래스를 엔티티 클래스라고 한다.\n  \n  \n    @Table\n엔티티 클래스에 매핑할 테이블 정보를 알려준다. @Table을 생략하면 클래스 이름을 테이블 이름으로 매핑한다. name 속성을 사용하여 원하는 테이블 명을 지정할 수 있다.\n  \n  \n    @Id\n엔티티 클래스의 필드를 테이블의 기본키(Primary Key)에 매핑한다. @Id가 사용된 필드를 식별자 필드라고 한다.\n  \n  \n    @Column\n필드를 컬럼에 매핑한다. name 속성을 사용하여 원하는 컬럼명을 지정할 수 있다.\n  \n  \n    매핑 정보가 없는 필드\n매핑 어노테이션을 생략하면 필드명을 사용해서 컬럼명으로 매핑한다.\n\n    JPA 어노테이션의 패키지는 javax.persistence 이다.\n  \n\n\n5. persistence.xml 설정\n\n\n  \n    JPA는 persistence.xml을 사용해서 필요한 설정 정보를 관리한다. 이 설정파일이 META-INF/persistence.xml 클래스 패스 경로에 있으면 별도의 설정 없이 JPA가 인식할 수 있다.\n  \n  \n    &amp;lt;persistence-unit name=&quot;jpabook&quot;&amp;gt;\nJPA 설정은 영속성 유닛이라는 것부터 시작하는데 일반적으로 연결할 데이터베이스당 하나의 영속성 유닛을 등록한다. 영속성 유닛에는 고유한 이름을 부여해야 한다.\n  \n  JPA 표준 속성\n    \n      javax.persistence.jdbc.driver : JDBC 드라이버\n      javax.persistence.jdbc.user : 데이터베이스 접속 아이디\n      javax.persistence.jdbc.passowrd : 데이터베이스 접속 비밀번호\n      javax.persistence.jdbc.url : 데이터베이스 접속 URL\n      \n    \n  \n  하이버네이트 속성\n    \n      hibernate.dialect : 데이터베이스 방언(Dialect)설정\n      hibernate.show_sql : 하이버네이트가 실행한 SQL을 출력한다.\n      hibernate.formt_sql : 하이버네이트가 실행한 SQL을 출력할 때 보기 쉽게 정렬한다.\n      hibernate.use_sql_comments : 쿼리를 출력할 때 주석도 함께 출력한다.\n      hibernate_id.new_generator_mappings : JPA 표준에 맞춘 새로운 키 생성 전략을 사용한다.\n    \n  \n  \n    JPA 표준 속성은 특정 구현체에 종속되지 않는다. 반면에 하이버네이트 전용 속성은 하이버네이트에서만 사용할 수 있다.\n  \n  \n    SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능을 방언(Dialect)이라고 한다.\n\n    \n  \n\n\n6. 애플리케이션 개발\n\n▪️ 엔티티 매니저 설정\n\n\n\n\n  \n    엔티티 매니저 팩토리\n엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야 한다.\n  \n  \n    엔티티 매니저  \nJPA의 기능 대부분은 엔티티 매너저가 제공한다.\n엔티티 매니저는 내부에 데이터소스(데이터베이스 커넥션)를 유지하면서 데이터베이스와 통신한다.\n엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용하면 안된다.\n  \n\n\n▪️ 트랜잭션 관리\n\n\n  JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다.\n\n\n▪️ JPQL\n\n\n  JPA는 SQL을 추상화한 JPAL이라는 객체지향 쿼리 언어를 제공한다.\n  JPQL은 엔티티 객체를 대상으로 쿼리한다. 쉽게 이야기해서 클래스와 필드를 대상으로 쿼리한다.\n  JPQL은 데이터베이스 테이블을 전혀 알지 못하고 엔티티 객체를 참조한다.\n\n\n//목록 조회\nTypedQuery&amp;lt;Member&amp;gt; query = em.createQurery(&quot;select m from Member m&quot;, Member.class);\nList&amp;lt;Member&amp;gt; members = query.getResultLiost\n\n\n\n   Reference\n   자바 ORM 표준 JPA\n\n"
} ,
  
  {
    "title"    : "토비의 스프링 - 1장. 오브젝트와 의존관계(2)",
    "category" : "Book",
    "url"      : "/book/2022/02/05/toby-1-3/",
    "date"     : "February 5, 2022",
    "excerpt"  : "1.3 DAO의 확장\n1.3.1 클래스의 분리\n1.3.2 인터페이스의 도입\n1.3.3 관계 설정 책임의 분리\n1.3.4 원칙과 패턴\n\n1.3 DAO의 확장\n\n  지금까지 데이터 액세스 로직을 어떻게 만들 것인가와 DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다.\n  변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.\n\n\n클래스의 분리\n\n\n\n\n  SimpleConnectionMak...",
    "content"  : "1.3 DAO의 확장\n1.3.1 클래스의 분리\n1.3.2 인터페이스의 도입\n1.3.3 관계 설정 책임의 분리\n1.3.4 원칙과 패턴\n\n1.3 DAO의 확장\n\n  지금까지 데이터 액세스 로직을 어떻게 만들 것인가와 DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다.\n  변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.\n\n\n클래스의 분리\n\n\n\n\n  SimpleConnectionMaker라는 새로운 클래스를 만들고 DB 생성 기능을 그 안에 넣는다.\n  예제 코드\n    \n      독립된 SimpleConnectionMaker를 사용하게 만든 UserDao\n      독립시킨 DB 연결 기능인 SimpleConnectionMaker\n      \n    \n  \n  클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.\n    \n      SimpleConnectionMaker의 메소드가 달라지면 일일이 수정해야 한다는 점\n    \n    \n      DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 한다는 점\n    \n    이런 문제의 근본적인 원인은 UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다.\n    \n      \n    \n  \n\n\n인터페이스의 도입\n\n  가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다.\n  추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이다.\n  자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스다.\n\n\n\n\n\n  이제 UserDao는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원하는 기능을 사용하기만 하면 된다.\n  예제 코드\n    \n      ConnectionMaker 인터페이스\n      ConnectionMaker 구현 클래스\n      ConnectionMaker 인터페이스를 사용하도록 개선한 UserDao\n      \n    \n  \n\n\n관계 설정 책임의 분리\n\n\n  \n    인터페이스를 이용한 분리에도 불구하고 여전히 UserDao 변경 없이 DB 커넥션 기능의 확장이 자유롭지 못하다.\n\n      public UserDao() {\n      connectionMaker = new DConnectionMaker();\n  }\n    \n    \n      어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지에 대한 관심사가 UserDao 생성자에 포함되어 있다.\n      이 관심사를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.\n      ConnectionMaker 인터페이스를 사용한 덕분에 UserDao와 ConnectionMaker의 구현 클래스들은 직접 연결되어 있지 않은 것처럼 보인다.\n      하지만 UserDao 에서 new DConnectionMacker() 를 해주는 코드가 있음으로써 클래스 사이에 직접적인 관계가 있다.\n      UserDao가 NConnectionMaker를 사용하게 하려면 UserDao의 코드를 변경해야 한다.\n    \n\n    \n\n    \n      클래스 사이에 관계가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다.\n      오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.\n    \n    \n      \n    \n  \n  이 문제를 해결하려면 객체지향의 다형성이라는 특징을 이용하면 된다.\n    \n      특정 클래스를 알지 못하더라도 해당 클래스가 인터페이스를 구현했다면, 그 클래스의 인터페이스 타입을 사용할 수 있다.\n      \n        UserDao가 DConnectionMacker를 사용하게 하려면 두 클래스 사이에 런타임 사용관계(=링크 =의존관계)를 맺어주면 된다.\n\n        \n      \n      ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성하는 책임을 UserDao의 생성자가 아니라 UserDao의 클라이언트에게 넘기도록 수정한다.\n      \n    \n  \n  예제 코드\n    \n      UserDao - 수정한 생성자\n      \n        관계설정 책임이 추가된 UserDao 클라이언트인 main() 메소드\n      \n      이제 UserDao는 자신의 관심사이자 책임인 사용자 데이터 액세스 작업을 수행하는데만 집중할 수 있다.\n      더 이상 DB 생성 방법이나 전략에 대해서는 고민할 필요가 없다.\n      \n    \n\n    \n\n    인터페이스를 도입하고 클라이언트의 도움을 받는 방법은 상속을 사용하는 것에 비해서 훨씬 더 유연하다.\n\n    \n      \n    \n  \n\n\n객체지향 설계와 프로그래밍 이론을 통해서 지금까지 적용한 벙법을 정리해보자 객체 지향 설계 원칙(SOLID)\n\n원칙과 패턴\n\n개방 폐쇄 원칙\n\n개방 폐쇄 원칙(OCP, Open-Closed Principle)은 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙이다.\nUserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려 있다. 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 변화에 영향을 받지 않으므로 변경에는 닫혀 있다.\n\n  \n\n\n객체지향 설계 원칙(SOLID)\n\n  \n\n\n높은 응집도 낮은 결합도\n\n\n  응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.\n  높은 응집도는 클래스 레벨뿐 아니라 패키지, 컴포넌트, 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.\n  응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수도 있다.\n\n\n처음에 개발한 초난감 DAO처럼 여러 관심사와 책임이 얽혀있는 복잡한 코드에서는 변경이 필요한 부분을 찾아내는 것도 번거로울뿐더러 변경으로 인한 오류를 발생시키지 않는지도 일일이 확인해야 한다.\n반면, ConnectionMaker 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우, DB 커넥션 풀을 활용하는 ConnectionMaker 구현 클래스를 새로 만들기만 하면 된다.\n\n\n  낮은 결합도는 높은 응집도보다 더 민감한 원칙이다.\n  결합도란 하나의 오브젝트에 변경이 일어날 때, 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도이다.\n\n\nConnectionMaker 인터페이스의 도입으로 인해 DB 연결 기능을 구현한 클래스가 바뀌더라도 DAO의 코드는 변경될 필요가 없다.\nConnectionMaker의 클래스를 결정하는 책임을 DAO의 클라이언트로 분리한 덕분에 ConnectionMaker의 구현 클래스가 바뀌어도, DAO의 코드를 수정할 필요가 없다.\n\n  \n\n\n전략 패턴\n\n  개선한 UserDtoTest, UserDao, ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다.\n  전략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 자주 사용되는 패턴이다.\n  전략 패턴은 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘(=전략)을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 클래스를 바꿔서 사용할 수 있게 하는 디자인 패턴이다.\n\n\nUserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스(=전략)를 바꿔가면서 사용할 수 있게 분리했다.\n\n\n   Reference\n   [토비 스프링] 사용자 DAO\n   [토비의 스프링 vol.1]1장 오브젝트와 의존관계\n\n"
} ,
  
  {
    "title"    : "라이브러리 VS. 프레임워크",
    "category" : "Programming",
    "url"      : "/programming/2022/02/04/library-framework/",
    "date"     : "February 4, 2022",
    "excerpt"  : "1) Library 정의\n\n  다른 프로그램들과 링크되기 위하여 존재하는 비휘발성 자원의 모임이다.\n응용프로그램 개발을 위해 필요한 기능을 모아 놓은 소프트웨어\n    \n      구성 데이터, 문서, 서브루틴(함수), 클래스, 값 등을 포함할 수 있다.\n      보통 링크 될 수 있도록 컴파일된 형태인 목적코드(object code) 형태로 존재한다.\n    \n  \n  다른 프로그램과 링크되는 방식에 따라 정적 라이브러리와 동적 라이브...",
    "content"  : "1) Library 정의\n\n  다른 프로그램들과 링크되기 위하여 존재하는 비휘발성 자원의 모임이다.\n응용프로그램 개발을 위해 필요한 기능을 모아 놓은 소프트웨어\n    \n      구성 데이터, 문서, 서브루틴(함수), 클래스, 값 등을 포함할 수 있다.\n      보통 링크 될 수 있도록 컴파일된 형태인 목적코드(object code) 형태로 존재한다.\n    \n  \n  다른 프로그램과 링크되는 방식에 따라 정적 라이브러리와 동적 라이브러리(공유 라이브러리)로 구분한다.\n\n\n2) Library 특징\n\n  유저의 코드가 라이브러리를 호출해서 사용하는 구조로 동작한다.\n실행 흐름에 대한 제어를 유저 코드가 담당\n  기능들을 어떻게 사용할지 사용자가 결정한다.\n  라이브러리를 사용하면 코드의 재사용, 부품화, 기술의 유출을 방지, 개발 시간을 단축 등의 장점이 있다.\n\n\n3) Framework 정의\n\n  소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게 일련의 협업화된 형태로 클래스들을 제공하는 것\n-랄프 존슨(Ralph Johnson)\n\n\n\n  프레임워크는 소프트웨어 개발을 위해 구조적인 틀과 구현코드를 함께 제공한다.\n프레임워크 = 디자인 패턴 + 라이브러리\n    \n      프레임워크는 애플리케이션의 구조와 디자인(디자인 패턴)을 결정한다.\n      디자인 패턴이 적용되어 구현된 기반코드(라이브러리)를 제공한다.\n    \n  \n\n\n4) Framework  특징\n\n  디자인 패턴은 프레임워크의 핵심적인 특징이고, 프레임워크를 사용하는 애플리케이션에 그 패턴이 적용된다.\n  프레임워크 쪽에서 사용자의 코드를 호출하는 구조로 동작한다.\n실행 흐름에 대한 제어를 프레임워크가 담당\n➡︎  제어의 역전 개념이 적용된 대표적인 기법\n  많은 프레임워크는 템플릿 메소드 패턴 기반으로 만들어진 클래스를 서브 클래싱해서 사용하도록 되어있다.\n이미 설계되어있는 흐름구조에 따라 동작하게 된다.\n\n\n5) Framework와  Library 비교\n\n\n라이브러리와 프레임워크의 차이는 응용프로그램의 흐름 주도권을 누가 가지고 있는가이다.\n\n\n\nFramework 활용의 지름길\n- 프레임워크의 라이브러리를 살펴볼 때, 적용된 디자인 패턴을 주목해서 살펴보자.\n- 레퍼런스 매뉴얼과 API/클래스 문서를 꾸준히 보고, 유용한 라이브러리 기능에 대한 지식을 쌓자.\n\n\n  Reference\n  프레임워크의 재발견\n  정적 라이브러리(Static Library) &amp;amp; 공유 라이브러리(Shared Library)\n  API vs 라이브러리 vs 프레임워크\n\n\n"
} ,
  
  {
    "title"    : "토비의 스프링 - 1장. 오브젝트와 의존관계(1)",
    "category" : "Book",
    "url"      : "/book/2022/02/04/toby-1-2/",
    "date"     : "February 4, 2022",
    "excerpt"  : "들어가며\n1.1 초난감 DAO\n1.2 DAO의 분리\n\n들어가며\n\n스프링이란 무엇인가?\n\n  애플리케이션의 기본 틀 - 스프링 컨테이너\n    \n      스프링 컨테이너(=애플리케이션 컨텍스트) : 스프링에서 제공하는 런타임 엔진\n      스프링 컨테이너는 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트(=Bean)를 생성하고 관리한다.\n      \n    \n  \n  공통 프로그래밍 모델 - IoC/DI, 서비스 추상화, AOP\n ...",
    "content"  : "들어가며\n1.1 초난감 DAO\n1.2 DAO의 분리\n\n들어가며\n\n스프링이란 무엇인가?\n\n  애플리케이션의 기본 틀 - 스프링 컨테이너\n    \n      스프링 컨테이너(=애플리케이션 컨텍스트) : 스프링에서 제공하는 런타임 엔진\n      스프링 컨테이너는 설정 정보를 참고해서 애플리케이션을 구성하는 오브젝트(=Bean)를 생성하고 관리한다.\n      \n    \n  \n  공통 프로그래밍 모델 - IoC/DI, 서비스 추상화, AOP\n 스프링 프레임워크의 3가지 프로그레밍 모델 (라이브러리 VS. 프레임워크)\n    \n      IoC/DI\n        \n          오브젝트의 생명주기와 의존관계에 대한 프로그레밍 모델이다.\n          스프링은 객체지향 설계 원칙과 디자인 패턴의 핵심 원리를 담고 있는 IoC/DI를 프레임워크의 근간으로 삼고 있다.\n        \n      \n      서비스 추상화\n        \n          구체적인 기술과 환경에 종속되지 않도록 유연한 추상 계층을 두는 방법이다.\n        \n      \n      AOP\n        \n          애플리케이션 코드에 산재해서 나타나는 부가적인 기능을 독립적으로 모듈화하는 프로그래밍 모델이다.\n          \n        \n      \n    \n  \n  기술 API\n    \n      스프링은 개발의 다양한 영역에 바로 활용할 수 있는 방대한 양의 기술 API를 제공한다.\n    \n  \n\n\n1.1 초난감 DAO\n\n  JDBC를 이용하는 작업의 일반적인 순서\n    \n      DB 연결을 위한 Connection을 가져온다.\n      SQL 을 담은 Statement(또는 PreparedStatement)를 만든다.\n      만들어진 Statement를 실행한다.\n      조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.\n      작업 중에 생성된 Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 반드시 닫아준다.\n    \n  \n  예제 코드\n    \n      사용자 정보 저장용 자바빈 User 클래스\n      JDBC를 이용한 등록과 조회 기능이 있는 UserDao\n    \n  \n\n\n1.2 DAO의 분리\n관심사의 분리\n\n  객체지향 설계와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다.\n\n\n  그러면 어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있었을까? 그것은 분리와 확장을 고려한 설계가 있었기 때문이다.\n\n\n  관심사의 분리란, 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것이다.\n\n\n  \n  중복 코드 메소드 추출\n    \n      예제 코드 \n- getConnection() 메소드를 추출해서 중복을 제거한 UserDao\n      \n    \n  \n  변경사항에 대한 검증: 리팩토링과 테스트\n    \n      main() 메소드를 이용해 테스트를 실행한다.\n      두번째 테스트 부터는 테이블의 기본키인 id 값이 중복되기 때문에 예외가 발생한다.\n      main() 메소드 테스트를 다시 실행하기 전에 User 테이블의 사용자 정보를 삭제해줘야 한다.\n    \n\n    리팩토링\n리팩토링인 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.\n  \n  \n  상속을 통한 확장\n    \n      예제 코드\n- 상속을 통한 확장 방법이 제공되는 UserDao\n\n      \n    \n\n    - 템플릿 메소드 패턴\n  슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법의 디자인 패턴\n  \n  - 팩토리 메소드 패턴\n  서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 디자인 패턴\n\n    \n\n    디자인 패턴\n  디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다.\n  디자인 패턴을 사용하면 설계의 의도와 해결책을 파악하기 쉽다는 장점이 있다.\n\n    \n      상속의 한계\n        \n          만약 UserDao가 다른 목적을 위해 상속을 사용하고 있다면, 자바에서 다중상속을 허용하지 않기 때문에 상속을 사용할 수 없다.\n        \n        \n          상속을 통한 부모-자식 클래스의 관계는 생각보다 밀접하다. 그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나, 서브클래스의 변경이 슈퍼클래스에 영향을 주지 않도록 제한해야 한다.\n        \n        \n          만약 다른 DAO 클래스를 만들어야 하는 경우, getConnection() 구현 코드가 중복된다.\n        \n      \n    \n  \n\n\n\n   Reference\n   [토비 스프링] 사용자 DAO\n   [토비의 스프링 vol.1]1장 오브젝트와 의존관계\n\n"
} ,
  
  {
    "title"    : "자바 ORM 표준 JPA 프로그래밍 - (1) JPA 소개",
    "category" : "Book",
    "url"      : "/book/2022/02/03/jpa-1/",
    "date"     : "February 3, 2022",
    "excerpt"  : "1. SQL을 직접 다룰때 발생하는 문제점\n2. 패러다임의 불일치\n3. JPA란 무엇일까?\n\n\n  “왜 실무에서 테이블 설계는 다들 열심히 하면서 제대로 된 객체 모델링은 하지 않을까?”\n\n\n\n  “왜 객체 지향의 장점을 포기하고 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하도록 개발할까?”\n\n\n1. SQL을 직접 다룰때 발생하는 문제점\n\n\n  진정한 의미의 계층 분할이 어렵다.\n  엔티티를 신뢰할 수 없다.\n  SQL에 의존적인 ...",
    "content"  : "1. SQL을 직접 다룰때 발생하는 문제점\n2. 패러다임의 불일치\n3. JPA란 무엇일까?\n\n\n  “왜 실무에서 테이블 설계는 다들 열심히 하면서 제대로 된 객체 모델링은 하지 않을까?”\n\n\n\n  “왜 객체 지향의 장점을 포기하고 객체를 단순히 테이블에 맞추어 데이터 전달 역할만 하도록 개발할까?”\n\n\n1. SQL을 직접 다룰때 발생하는 문제점\n\n\n  진정한 의미의 계층 분할이 어렵다.\n  엔티티를 신뢰할 수 없다.\n  SQL에 의존적인 개발을 피하기 어렵다.\n\n\n2. 패러다임의 불일치\n\n\n  관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다. 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다.\n  따라서 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.\n  문제는 객체와 관계형 데이터베이스 사이의 패러다임 불일치 문제를 해결하는데 너무 많은 시간과 코드를 소비하는데 있다.\n  \n    결국, 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다.\n\n    연관관계\n\n    \n      객체는 참조를 사용해서 다른 객체와 연과관계를 가지고 참조에 접근해서 연관된 객체를 조회한다. 반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.\n      객체를 테이블에 맞추어 모델링하면 객체를 테이블에 저장하거나 조회할 때는 편리하다.\n      하지만 객체는 연관된 객체의 참조를 통해 연관된 객체를 찾을 수 있다.\n      객체 모델은 외래키가 필요 없고, 참조만 있으면 된다.\n      반면에 테이블은 참조가 필요 없고 외래키만 있으면 된다.\n      JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다.\n    \n\n    객체 그래프 탐색\n\n    \n      객체에서 참조를 사용해서 연관된 팀을 찾는 것을 객체 그래프 탐색이라고 한다.\nmember.getOrder().getOrderItem()...\n      SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.\n      결국 조회하는 메소드를 상황에 따라 여러 벌 만들어서 사용해야 한다.\n      JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다. 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 마음껏 조회할 수 있다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 해서 지연 로딩이라 한다.\n    \n\n    비교\n\n    \n      \n        데이터베이서는 기본 키의 값으로 각 로우를 구분한다. 반면에 객체는 동일성(identity) 비교와 동등성(equality) 비교라는 두 가지 비교 방법이 있다.\n따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.\n\n        String memberUd = &quot;100&quot;;\nMember member1 = memberDAO.getMember(memberId);\nMember member2 = memberDAO.getMember(memberId);\n    \nmember1 == member2 //다르다\n        \n      \n      위의 코드에서 기본 키 값이 같은 회원 객체를 두 번 조회했다. 그런데 둘을 동일성(==) 비교 하면 false가 반환된다. 왜냐하면 member1과 member2는 같은 데이터베이스 로우에서 조회했지만, 객체 측면에서 볼 때 둘은 서로 다른 인스턴스이기 때문이다.\n      JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.\n    \n  \n\n\n3. JPA란 무엇일까?\n\n\n  \n    JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준이다.\n\n    \n  \n  ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.\n  ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해준다.\n  \n    자바 진영에도 다양한 ORM 프레임워크들이 있는데 그중에 하이버네이트 프레임워크가 가장 많이 사용된다. 하이버네이트는 거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크이다.\n\n    \n  \n  JPA는 자바 ORM 기술에 대한 QPI 표준 명세다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다.\n  왜 JPA를 사용해야 하는가?\n    \n      유지보수\n      패러다임 불일치 해결\n      성능\n      데이터 접근 추상화와 벤터 독립성\n      표준\n    \n  \n\n\n\n   Reference\n   JPA 공부 시작!\n\n"
} ,
  
  {
    "title"    : "Macbook 에서 Java 설치하기",
    "category" : "Daily",
    "url"      : "/daily/2022/02/02/macbook-java/",
    "date"     : "February 2, 2022",
    "excerpt"  : "그동안 Window만 사용하다가 이번에 처음으로 Macbook으로 바꾸게 되었습니다.\n개발을 하면서 Linux, Ubuntu 도 간간이 사용하였지만, 주로 사용한 건 Window였기 때문에 macOS를 잘 다룰 수 있을지 걱정도 되었습니다. \n처음 개발을 배우던 시기에는 개발 환경을 세팅하는 것이 어렵게 느껴졌는데, 그래도 이제는 새로운 환경에 제법 잘 적응할 수 있게 된 것 같습니다. \nmacOS 관련해서는 더 공부가 필요하지만, 일단 ...",
    "content"  : "그동안 Window만 사용하다가 이번에 처음으로 Macbook으로 바꾸게 되었습니다.\n개발을 하면서 Linux, Ubuntu 도 간간이 사용하였지만, 주로 사용한 건 Window였기 때문에 macOS를 잘 다룰 수 있을지 걱정도 되었습니다. \n처음 개발을 배우던 시기에는 개발 환경을 세팅하는 것이 어렵게 느껴졌는데, 그래도 이제는 새로운 환경에 제법 잘 적응할 수 있게 된 것 같습니다. \nmacOS 관련해서는 더 공부가 필요하지만, 일단 필요한 개발 환경을 구축하면서 내용을 정리해 보았습니다.\n\nJava 설치 경로 및 버전 확인\n\n  기존에 설치된 Java 검색\n    brew search jdk\nbrew tap adoptopenjdk/openjdk\n    \n  \n  AdoptOpenJDK 설치\n    brew install --cask adoptopenjdk8\nbrew install --cask adoptopenjdk11\n    \n  \n  \n    Rosetta 2를 설치해야 하는 경우\nRosetta 2는 Intel 프로세서가 장착된 Mac용으로 제작된 앱을 Apple Silicon이 장착된 Mac에서 사용할 수 있게 해주는 에뮬레이터이다. 아래와 같은 메시지가 나오면 ‘설치’를 클릭한 다음 사용자 이름과 암호를 입력하여 설치를 진행한다.\n\n  \n  설치된 Java 검색\n    /usr/libexec/java_home -V\njava --version\n    \n  \n  \n\n\nJava 버전 바꾸기\n자바 버전을 바꾸는 방법중에는 jEnv를 활용하는 방법과 환경변수를 지정하는 방법이 있다.\n여기서는 환경 변수를 변경하는 방법으로 작성되었다.\n\n\n  \n    환경 설정 값과 경로들을 저장하는 파일을 찾는다.\nbash쉘을 사용하는 경우는 ~/.bash_profile이고 zsh쉘을 사용하는 경우 ~/.zshrc 파일을 수정한다.\n\n      echo $SHELL    # 어떤 쉘을 사용하는지 확인\n  vi ~/.zshrc\n    \n\n      # Java Paths\n  export JAVA_HOME_11=$(/usr/libexec/java_home -v11.0.11)\n  export JAVA_HOME_8=$(/usr/libexec/java_home -v1.8.0_292)\n    \n  # Java 11\n  export JAVA_HOME=$JAVA_HOME_11\n    \n  # Java 8\n  # export JAVA_HOME=$JAVA_HOME_8\n    \n  \n\n\n\n  Reference\n  Mac에 Rosetta를 설치해야 하는 경우\n  homebrew로 openjdk 설치하기\n  맥에서 Brew로 자바 설치하기(feat. 자바버전 바꾸기)\n  java_home and JAVA_HOME on macOS\n\n"
} ,
  
  {
    "title"    : "MacBook Setting",
    "category" : "Daily",
    "url"      : "/daily/2022/02/01/macbook/",
    "date"     : "February 1, 2022",
    "excerpt"  : "\n  homebrew 란 macOS 용 패키지 관리 애플리케이션입니다. homebrew는 주로 커맨드라인 도구나 시스템 패키지들을 설치하는 데 사용합니다. \n기본적으로 맥OS용 패키지 관리자이지만, 리눅스나 윈도우의 WSL도 지원하고 있습니다. homebrew는 편리하게 사용할 수 있다는 장점이 있습니다만, 커뮤니티 기반으로 운영되기 때문에 패키지의 안정성이 보장되지 않는다는 단점이 있습니다. 일부 리눅스 배포판의 경우 패키지 버전 정책이...",
    "content"  : "\n  homebrew 란 macOS 용 패키지 관리 애플리케이션입니다. homebrew는 주로 커맨드라인 도구나 시스템 패키지들을 설치하는 데 사용합니다. \n기본적으로 맥OS용 패키지 관리자이지만, 리눅스나 윈도우의 WSL도 지원하고 있습니다. homebrew는 편리하게 사용할 수 있다는 장점이 있습니다만, 커뮤니티 기반으로 운영되기 때문에 패키지의 안정성이 보장되지 않는다는 단점이 있습니다. 일부 리눅스 배포판의 경우 패키지 버전 정책이 매우 보수적이지만, homebrew로 패키지를 설치하는 경우 거의 항상 최신 버전이 설치됩니다. 구버전의 패키지를 설치하는 것도 가능하지만 번거로운 편입니다.\n\n\n\n  cask 확장을 통해 웹 사이트에서 다운받을 수 있는 애플리케이션을 설치할 수 있습니다.\n\n\n  mas 확장을 통해 앱 스토어에서 다운받을 수 애플리케이션 설치할 수 있습니다.\n\n\n1. 맥북 프로그램 설치\n\n1) homebrew 설치\n\n  \n    Homebrew 홈페이지에서 설치 명령어를 복사하여 터미널에서 실행\n\n     /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;\n    \n    password 입력 후, Enter 로 확인\n  \n  \n    설치가 완료되면 환경 변수 추가 메시지 로그를 확인\n\n    ==&amp;gt; Next steps:\n- Add Homebrew to your PATH in /Users/&amp;lt;USER_ID&amp;gt;/.zprofile:\n  echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &amp;gt;&amp;gt; /Users/&amp;lt;USER_ID&amp;gt;/.zprofile\n  eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;\n- Run `brew help` to get started\n- Further documentation:\n  https://docs.brew.sh\n    \n  \n  \n    환경 변수 추가\n\n    echo &#39;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#39; &amp;gt;&amp;gt; [path]/.zprofile\neval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;\n    \n  \n\n\n2) brew cask 설치\nbrew install cask \n\n\n3) brew mas 설치\nbrew install mas \n\n\n2. homebrew 설치 기본 명령\n\n1) brew 명령어\nbrew list\nbrew search [패키지명]\nbrew info [패키지명]\nbrew install [패키지명]\nbrew uninstall [패키지명]\n\n\n2) cask 명령어\nbrew list --cask\nbrew search --cask [앱이름]\nbrew info --cask [앱이름]\nbrew install --cask [앱이름]\nbrew uninstall --cask [앱이름]\n\n\n3) mas 명령어\nmas list\nmas search [앱이름]\nmas info [앱번호]\nbrew install mas [앱번호]\nbrew uninstall mas [앱번호]\n\n\n참고\n\n설치할 목록\n\n    \n      brew\n        \n          java\n          git\n          gradle\n          jq : 커맨드라인 JSON 프로세서\n          tree : tree 명령어\n        \n      \n      cask\n        \n          chrome\n          slack\n          docker\n          source tree\n          intellij-idea\n          vscode\n          iterm2\n          Spectacle : 화면 분할\n          Karabiner-Elements : 한/영키\n          Alfred : 검색\n          kap : 화면 기록\n        \n      \n      mas\n        \n          OneDrive\n          Excel\n          Word\n          Power point\n          Todo\n          kakaotalk\n          Joli of Caffeine : 절전 모드 시간 설정\n        \n      \n    \n  \n\n\n\nBundle 로 설치\n\n    \n      \n        brew file 생성 및 실행\n\n        cd ~\n  \n# 생성\nbrew bundle dump\n  \n# 덮어 씌우기\nbrew bundle -f dump\n  \n# 파일 확인\ncat BrewFile\n  \n# 실행\nbrew bundle\n        \n      \n    \n\n  \n\n\n\n  Reference\n  내가 설치한 맥용 어플리케이션들\n  애플 실리콘 M1 용 Homebrew 설치\n  맥북 추천 무료 앱 8가지 + 크롬 브라우저 익스텐션 1가지\n  Mac - brew(개발 환경 자동화)\n\n"
} ,
  
  {
    "title"    : "프로그래머 성장 과정 대한 정리",
    "category" : "Programming",
    "url"      : "/programming/2022/01/31/growing-up/",
    "date"     : "January 31, 2022",
    "excerpt"  : "어느날, Java를 프로그래밍 주 언어로 사용하지만 Java에 대한 지식이 부족하다는 생각이 들었습니다.\n개발에 필요한 지식만 익히지 말고 이번에는 제대로 기본기를 잡아보자! 하는 결심이 들어서 본격적으로 Java 공부를 다시 시작하게 되었습니다. \nJava 기본기 공부를 하기 위해 『Java의 정석』 책과 인프런의 『만들어 가면서 배우는 JAVA 플레이그라운드』 강의를 먼저 학습하기로 했습니다. \n막상 강의를 들으려는데, 초반 내용은 개...",
    "content"  : "어느날, Java를 프로그래밍 주 언어로 사용하지만 Java에 대한 지식이 부족하다는 생각이 들었습니다.\n개발에 필요한 지식만 익히지 말고 이번에는 제대로 기본기를 잡아보자! 하는 결심이 들어서 본격적으로 Java 공부를 다시 시작하게 되었습니다. \nJava 기본기 공부를 하기 위해 『Java의 정석』 책과 인프런의 『만들어 가면서 배우는 JAVA 플레이그라운드』 강의를 먼저 학습하기로 했습니다. \n막상 강의를 들으려는데, 초반 내용은 개발환경을 세팅하는 부분이라 ‘그냥 넘어갈까?’하는 마음이 들었습니다. \n그런데 프로그래밍 학습에 대한 어려움과 극복 방법, 연습에 대한 정리 내용이 있어서 듣다가 정말 중요하고 좋은 내용을 전해주셔서 글로 정리하게 되었습니다.\n\n프로그래밍 학습이 어려운 이유\n\n\n\n  개발을 하기 시작한 초반에는 숙련도가 낮아도 자심감이 어느정도 있지만, 숙련도가 높아짐에도 어느 시점에서 자신감이 많이 떨어지는 시기가 생긴다.\n  개발을 하기 시작한 초반에는 학습할 내용도 많고, 학습 자원도 매우 많지만 초급에서 중급 단계로 넘어가면서 학습할 자원들 찾기 어렵다고 느낀다.\n  숙련도가 높아지기 위해 학습해야 할 주제의 범위가 점점 많아진다.\n\n\n극복하는 방법\n\n\n\n  Hand-Holding Honeymoon\n    \n      다양한 초보 강의를 검토한 후 하나를 선택해서 학습\n      반복해서 연습하기\n    \n  \n  Cliff of Confusion\n    \n      같이 학습할 동료를 구하기\n      다른 사람의 코드 읽기\n      지속적으로 작은 코드를 시작하고 빌드하면서 디버깅에 대한 두려움을 제거하기 → 성취감 Up, 자신감 Up\n    \n  \n  Desert of Despair\n    \n      하나의 목표를 설정한 후 목표에 집중\n      수박 겉핦기 식의 다양한 지식 습득이 아니라 한 분야에 대한 깊이 있는 지식 습득\n      구체적인 목표 의식을 가지고 의식적인 연습을 함으로써 시간 낭비를 최소화\n    \n  \n  Upswing of Awesome\n    \n      Best practices를 찾아 연습하고, 지식의 빈틈을 보완\n      설계, 아키텍처, 배포와 같이 좋은 개발자가 되기 위한 연습\n      이 단계를 극복하기 위한 핵심은 피드백을 받는 것 → 코칭을 해줄 멘토나 동료를 찾는 것이 중요!\n    \n  \n\n\n프로그래밍 학습에서 취업까지 현실적인 조언\n\n  주변 정리 및 우선순위 조정이 필요하다. 방해받지 않고 프로그래밍에 집중할 수 있어야 한다.\n  프로그래머로 취업하기 위한 학습 기간이 필요하다(최소 1년). 그렇지 않으면 회사 일과 학습을 병행하는 것이 매우 힘들다.\n  개발이 처음이라면 온라인 교육 컨텐츠 보다는 단기 속성 학원을 추천한다. 하지만 학원에서 배운다고 프로그래밍적 사고를 제대로 갖추기는 어렵다. 무엇을 어떻게 학습할 것인지에 대한 감을 잡는 것이 필요하다.\n  같이 학습할 사람을 만드는 것이 가장 중요하다. 매일 일정한 시간, 장소로 출퇴근 하면서 꾸준하게 공부한다.\n  학습하면서 다음 단계로 무엇을 해야할지 모를 때, 포기하고 싶을 때에는 주변 강사님, 선배 개발자에게 조언을 구할 필요가 있다. 또, 가끔씩 회사에 지원해보면서 현재 나의 상태와 부족한 점을 파악하면서 재조정\n해본다.\n\n\n프로그래밍 학습 방식\n\n  기초 지식부터 쌓은 후 무엇인가를 만들어 가는 방식\n  무엇인가를 만들어 가면서 관련된 지식을 학습해 가는 방식\n\n\n자신이 어떤 방식으로 학습할 때 더 효과적으로 학습하는 성향인지 찾아야 한다.\n어떤 방식으로 학습할 때 스트레스를 덜 받고 즐거움을 느끼는지 찾아야 한다.\n\n프로그래밍 연습\n\n  무엇인가 한 가지를 끝낸 후, 바로 다음 단계로 넘어가기 보다는 어색하거나, 이해되지 않거나, 궁금한 내용을 정리하는 시간을 갖자\n  반복해서 연습하자\n  과정 속에서 배운 부분이 있으면 그날 그날 내용을 정리하는 습관을 갖자\n  호기심을 가지고 다양한 시도를 해보자\n\n\n\n   Reference\n   자바의 정석 강의\n   만들어 가면서 배우는 JAVA 플레이그라운드\n   Why Learning to Code is So Damn Hard\n\n\n"
} 
  
]
