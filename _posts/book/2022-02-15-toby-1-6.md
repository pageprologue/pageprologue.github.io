---
layout: post
title: 토비의 스프링 - 1장. 오브젝트와 의존관계(3)
categories: [Book]
---

[1.4 제어의 역전(IoC)](#14-제어의-역전(ioc))  
[1.5 스프링의 IoC](#15-스프링의-ioc)  
[1.6 싱글톤 레지스트리와 오브젝트 스코프](#16-싱글톤-레지스트리와-오브젝트-스코프)   
{:.notice-list}

### 1.4 제어의 역전(IoC)
- [이전 장](http://localhost:4000/book/2022/02/05/toby-1-3/#%EA%B4%80%EA%B3%84-%EC%84%A4%EC%A0%95-%EC%B1%85%EC%9E%84%EC%9D%98-%EB%B6%84%EB%A6%AC)
에서 `UserDao`가 `ConnectionMaker` 인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 `UserDao`의 클라이언트(=`UserDaoTest`)에게 그 책임을 넘기도록 수정했다.
- 하지만, `UserDaoTest`에서도 테스트 이외의 역할을 수행하므로, 성격이 다른 책임이나 관심사를 분리해야 한다.
- **이번 장에서는 분리시킬 기능의 오브젝트를 생성하고, 생성된 오브젝트가 연결되도록 관계를 맺어주는 방법에 대해 알아보자.**{:.pre-result .bold}
{:.notice .no-marker .no-indent}

#### 오브젝트 팩토리
- 분리시킬 기능을 담당하는 클래스를 만든다. 이 클래스의 역할은 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데, 이런 일을 하는 오브젝트를 흔히 **팩토리(factory)**{:.bg-blue .outline}라고 부른다.
- **예제 코드**{:.bg-lg .outline}
  - [UserDao의 생성 책임을 맡은 팩토리 클래스 - UserDaoFactory](https://github.com/pageprologue/toby-spring3-1/blob/main/Vol1-30/Ch1/1.4.1/src/springbook/user/dao/UserDaoFactory.java#LC1)

  기존의 UserDaoTest 에서는 UserDao를 생성하기 위해 connectionMaker 구현체를 넘겨주어야 했다.   
    **`new UserDao(connectionMaker)`**{:.pre-result}  
  변경된 UserDaoTest 에서는 UserDaoFactory에서 UserDao의 생성을 담당한다.  
    **`new UserDaoFactory().userDao()`**{:.pre-result}
  {:.notice-warning}

- 설계도로서의 팩토리 클래스
  - `UserDaoFactory` 클래스는 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있는 **설계도**와 같은 역할을 한다. 
    
  ![](https://media.vlpt.us/images/devjay/post/c25b4f78-de92-4b61-a2c6-a830bf3aaaa2/IMG_0008.jpg){:.center width="90%"}

  - `UserDaoFactory`를 분리했을 때 얻을 수 있는 장점은 매우 다양하지만, 그중에서 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.
  - {:.blank}


#### 오브젝트 팩토리의 활용
- 여러 개의 DAO를 생성해야 하는 경우에도 중복 되는 코드를 별도의 메소드로 분리한뒤 생성하면 된다.
- **예제 코드**{:.bg-lg .outline}
  - [여러 개의 DAO 생성 - DaoFactory](https://github.com/pageprologue/toby-spring3-1/blob/main/Vol1-30/Ch1/1.4.2/src/springbook/user/dao/DaoFactory.java#LC1)
  - {:.blank}


#### 제어권의 이전을 통한 제어관계 역전
- 제어의 역전이란, 간단히 **프로그램의 제어 흐름 구조가 뒤바뀌는 것이다.**

  초기에 개발한 UserDao를 보면 [테스트용 main() 메소드](https://github.com/pageprologue/toby-spring3-1/blob/main/Vol1-30/Ch1/1.1.3/src/springbook/user/dao/UserDao.java#LC52)에서 UserDao를 직접 생성하고 사용한다. UserDao 또한 자신이 사용할 ConnectionMaker의 구현 클래스를 자신이 결정하여, 언제 어떻게 만들지를 스스로 관장한다.
  {:.case-eg}

- {:.blank}
- 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 자신이 어떻게 만들어지고 어디서 사용되는지를 알 수 없다.
  - 서블릿이나 JSP, EJB처럼 컨테이너 안에서 동작하는 구조는 간단한 방식이긴 하지만 제어의 역전 개념이 적용되어 있다고 볼 수 있다.
  - 제어의 역전 개념이 적용된 예를 디자인패턴에서도 여럿 찾아볼 수 있다.  
    
    템플릿 메소드는 제어권을 상위 템플릿 메소드에게 넘기고 자신은 필요할 때 호출되어 사용되록 한다는, 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이라고 볼 수 있다.
    {:.case-eg}

  - {:.blank .half}
  - 프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. **([라이브러리 VS. 프레임워크](https://pageprologue.github.io/programming/2022/02/04/library-framework))**{:.case-link}
  - {:.blank}

- **제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.**

  원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었다. 그런데 지금은 DaoFactory에게 있다. DaoFactory는 오브젝트 수준의 가장 단순한 IoC 컨테이너(혹은 IoC 프레임워크)라고 불릴 수 있다.
  {:.case-eg}


### 1.5 스프링의 IoC
- 스프링은 IoC를 모든 기능의 기초가 되는 기반 기술로 삼고 있으며, IoC를 극한까지 적용하고 있는 프레임워크다.
- 스프링의 핵심을 담당하는 것은 **빈 팩토리(=애플리케이션 컨텍스트)**{:.bg-blue .outline}이다.


#### 오브젝트 팩토리를 이용한 스프링 IoC


#### 애플리케이션 컨텍스트의 동작방식


#### 스프링 IoC의 용어 정리


### 1.6 싱글톤 레지스트리와 오브젝트 스코프

#### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트


#### 싱글톤과 오브젝트의 상태


#### 스프링 빈의 스코프


<div class="post-reference">
   <p>Reference</p>
   <a href="https://velog.io/@devjay/Spring-%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84IoC">[Spring] 제어의 역전(IoC)</a>
</div>